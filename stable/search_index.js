var documenterSearchIndex = {"docs":
[{"location":"tutorial/Threading/#Multi-threading","page":"Multi-threading","title":"Multi-threading","text":"","category":"section"},{"location":"tutorial/Threading/","page":"Multi-threading","title":"Multi-threading","text":"In order to accelerate the computation via multi-threading parallel, please make sure Julia is started with multiple threads. A warning will be thrown to remind you when loading FiniteMPS with a single thread.","category":"page"},{"location":"tutorial/Threading/","page":"Multi-threading","title":"Multi-threading","text":"If the linear algebra backend is OpenBlas, nested multi-threading is forbidden (a related discussion here). So just close the parallelism of BLAS via","category":"page"},{"location":"tutorial/Threading/","page":"Multi-threading","title":"Multi-threading","text":"BLAS.set_num_threads(1)","category":"page"},{"location":"tutorial/Threading/","page":"Multi-threading","title":"Multi-threading","text":"When using MKL as the linear algebra backend, you can set the number of blas threads similarly, in which case nested multi-threading is allowed. Note MKL is invalid for some cpus and you should also close the BLAS parallelism in such case. You can follow MKL.jl to check if MKL is loaded successfully or not.","category":"page"},{"location":"tutorial/Threading/","page":"Multi-threading","title":"Multi-threading","text":"Please make sure the total threads number is not larger than the cpu cores (physical, without hyper-threading). Otherwise, the performance will become much worse due to conflict. The total threads can be estimated as    ","category":"page"},{"location":"tutorial/Threading/","page":"Multi-threading","title":"Multi-threading","text":"Threads.nthreads() * BLAS.get_num_threads()","category":"page"},{"location":"localspace/Fermion/#Fermion","page":"Fermion","title":"Fermion","text":"","category":"section"},{"location":"localspace/Fermion/","page":"Fermion","title":"Fermion","text":"Predefined local spaces for fermions.","category":"page"},{"location":"localspace/Fermion/#Spinless-fermion","page":"Fermion","title":"Spinless fermion","text":"","category":"section"},{"location":"localspace/Fermion/#FiniteMPS.U₁SpinlessFermion","page":"Fermion","title":"FiniteMPS.U₁SpinlessFermion","text":" module U₁SpinlessFermion\n\nPrepare some commonly used objects for U₁ spinless fermions.\n\nFields\n\n pspace::VectorSpace\n\nLocal d = 2 Hilbert space.\n\n Z::TensorMap\n\nRank-2 fermion parity operator Z = (-1)^n.\n\n n::TensorMap\n\nRank-2 particle number operator.\n\n FdagF::NTuple{2, TensorMap}\n\nTwo rank-3 operators of hopping c^dag c.\n\n FFdag::NTuple{2, TensorMap}\n\nTwo rank-3 operators of hopping c c^dag.\n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.U1SpinlessFermion","page":"Fermion","title":"FiniteMPS.U1SpinlessFermion","text":" const U1SpinlessFermion = U₁SpinlessFermion\n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#Spin-1/2-fermion","page":"Fermion","title":"Spin-1/2 fermion","text":"","category":"section"},{"location":"localspace/Fermion/#FiniteMPS.U₁SU₂Fermion","page":"Fermion","title":"FiniteMPS.U₁SU₂Fermion","text":" module U₁SU₂Fermion\n\nPrepare some commonly used objects for U₁×SU₂ fermions.\n\nNothing is exported, please call U₁SU₂Fermion.xxx to use xxx. \n\nFields\n\n pspace::VectorSpace\n\nLocal d = 4 Hilbert space.\n\n Z::TensorMap\n\nRank-2 fermion parity operator Z = (-1)^n.\n\n n::TensorMap\n\nRank-2 particle number operator n = n↑ + n↓.\n\n nd::TensorMap\n\nRank-2 double occupancy operator nd = n↑n↓.\n\n SS::NTuple{2, TensorMap}\n\nTwo rank-3 operators of Heisenberg S⋅S interaction.\n\n SSS::NTuple{3, TensorMap}\n\nThree operators of chiral operator imag(S⋅(S×S)). Rank = (3, 4, 3). SSS = imag(S⋅(S×S)) = -im * S⋅(S×S)  –>  S⋅(S×S) = im * SSS NOTICE: The chiral operator S⋅(S×S) is a pure imaginary operator under the current basis. Thus define SSS as the imaginary part of S⋅(S×S) to reduce the computational overhead.\n\n FdagF::NTuple{2, TensorMap}\n\nTwo rank-3 operators of hopping c↑^dag c↑ + c↓^dag c↓. \n\n FFdag::NTuple{2, TensorMap}\n\nTwo rank-3 operators of hopping c↑ c↑^dag + c↓ c↓^dag. \n\n ΔₛdagΔₛ::NTuple{4, TensorMap}\n\nFour operators of singlet pairing correlation Δₛ^dagΔₛ, where Δₛ = (c↓c↑ - c↑c↓)/√2. Rank = (3, 4, 4, 3).\n\n ΔₜdagΔₜ::NTuple{4, TensorMap}\n\nFour operators of triplet pairing correlation Δₜ^dag⋅Δₜ, where Δₜ is the triplet pairing operator that carries 2 charge and 1 spin quantum numbers. Rank = (3, 4, 4, 3).\n\n Δₛ::NTuple{2, TensorMap}\n Δₛdag::NTuple{2, TensorMap}\n\nSinglet pairing operators Δₛ and Δₛ^dag. Rank = (4, 3). Note the first operator has nontrivial left bond index.\n\n CpCm::NTuple{2, TensorMap}\n\nTwo rank-3 operators of C+C- correlation where C+ = c↑^dag c↓^dag and C- = C+^dag = c↓c↑. Note both operators are bosonic.\n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.U1SU2Fermion","page":"Fermion","title":"FiniteMPS.U1SU2Fermion","text":" const U1SU2Fermion = U₁SU₂Fermion\n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.ℤ₂SU₂Fermion","page":"Fermion","title":"FiniteMPS.ℤ₂SU₂Fermion","text":" module ℤ₂SU₂Fermion\n\nPrepare some commonly used objects for ℤ₂×SU₂ fermions. Basis convention in (0, 0) sector is {|0⟩, |↑↓⟩}.\n\nEach operator has the same name and behavior as U₁SU₂Fermion, details please see U₁SU₂Fermion.\n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.Z2SU2Fermion","page":"Fermion","title":"FiniteMPS.Z2SU2Fermion","text":" const Z2SU2Fermion = ℤ₂SU₂Fermion\n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.U₁U₁Fermion","page":"Fermion","title":"FiniteMPS.U₁U₁Fermion","text":" module U₁U₁Fermion\n\nPrepare the local space of d = 4 spin-1/2 fermions with U₁ charge and U₁ spin symmetry.\n\nFields\n\n pspace::VectorSpace\n\nLocal d = 4 Hilbert space.\n\n Z::TensorMap\n\nRank-2 fermion parity operator Z = (-1)^n.\n\n n₊::TensorMap\n n₋::TensorMap\n n::TensorMap\n\nRank-2 particle number operators. ₊ and ₋ denote spin up and down as ↑ and ↓ cannot be used in variable names.\n\n nd::TensorMap\n\nRank-2 double occupancy operator nd = n↑n↓.\n\n Sz::TensorMap\n\nRank-2 spin-z operator Sz = (n↑ - n↓)/2.\n\n S₊₋::NTuple{2, TensorMap}\n S₋₊::NTuple{2, TensorMap}\n\nTwo rank-3 operators of S₊₋ and S₋₊ interaction. Note Heisenberg S⋅S = SzSz + (S₊₋ + S₋₊)/2.\n\n FdagF₊::NTuple{2, TensorMap}\n FdagF₋::NTuple{2, TensorMap}\n\nTwo rank-3 operators of hopping c↑^dag c↑ and c↓^dag c↓.\n\n FFdag₊::NTuple{2, TensorMap}\n FFdag₋::NTuple{2, TensorMap}\n\nTwo rank-3 operators of hopping c↑ c↑^dag and c↓ c↓^dag.\n\n ΔdagΔ₊₊::NTuple{4, TensorMap}\n ΔdagΔ₋₋::NTuple{4, TensorMap}\n ΔdagΔ₊₋::NTuple{4, TensorMap}\n\nRank-4 operators of pairing correlation. Note ΔdagΔ₊₋ means c↑^dag c↓^dag c↓ c↑.\n\n EdagE₊::NTuple{4, TensorMap}\n EdagE₋::NTuple{4, TensorMap}\n\nRank-4 operators of triplet exciton correlation. Note EdagE₊ means c↑^dag c↓ c↑ c↓^dag so (i, j, i, j) gives the correlation of the same pair.  \n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.U1U1Fermion","page":"Fermion","title":"FiniteMPS.U1U1Fermion","text":" const U1U1Fermion = U₁U₁Fermion\n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#tJ-fermion","page":"Fermion","title":"tJ fermion","text":"","category":"section"},{"location":"localspace/Fermion/","page":"Fermion","title":"Fermion","text":"Spin-1/2 fermion without double occupancy.","category":"page"},{"location":"localspace/Fermion/#FiniteMPS.U₁SU₂tJFermion","page":"Fermion","title":"FiniteMPS.U₁SU₂tJFermion","text":" module U₁SU₂tJFermion\n\nPrepare some commonly used objects for U₁×SU₂ tJ fermions, i.e. local d = 3 Hilbert space without double occupancy. \n\nBehaviors of all operators are the same as U₁SU₂Fermion up to the projection, details please see U₁SU₂Fermion. \n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.U1SU2tJFermion","page":"Fermion","title":"FiniteMPS.U1SU2tJFermion","text":" const U1SU2tJFermion = U₁SU₂tJFermion\n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.U₁U₁tJFermion","page":"Fermion","title":"FiniteMPS.U₁U₁tJFermion","text":" module U₁U₁tJFermion\n\nPrepare some commonly used objects for U₁×U₁ tJ fermions, i.e. local d = 3 Hilbert space without double occupancy. \n\nBehaviors of all operators are the same as U₁U₁Fermion up to the projection, details please see U₁U₁Fermion. \n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.U1U1tJFermion","page":"Fermion","title":"FiniteMPS.U1U1tJFermion","text":" const U1U1tJFermion = U₁U₁tJFermion\n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.ℤ₂SU₂tJFermion","page":"Fermion","title":"FiniteMPS.ℤ₂SU₂tJFermion","text":" module ℤ₂SU₂tJFermion\n\nPrepare some commonly used objects for ℤ₂×SU₂ tJ fermions, i.e. local d = 3 Hilbert space without double occupancy. \n\nBehaviors of all operators are the same as ℤ₂SU₂Fermion up to the projection, details please see ℤ₂SU₂Fermion.\n\n\n\n\n\n","category":"module"},{"location":"localspace/Fermion/#FiniteMPS.Z2SU2tJFermion","page":"Fermion","title":"FiniteMPS.Z2SU2tJFermion","text":" const Z2SU2tJFermion = ℤ₂SU₂tJFermion\n\n\n\n\n\n","category":"module"},{"location":"lib/ObsTree/#Observable-Tree","page":"Observable Tree","title":"Observable Tree","text":"","category":"section"},{"location":"lib/ObsTree/","page":"Observable Tree","title":"Observable Tree","text":"Similar with InteractionTree, for computing expectation value of observables.","category":"page"},{"location":"lib/ObsTree/#FiniteMPS.ObservableTree","page":"Observable Tree","title":"FiniteMPS.ObservableTree","text":"struct ObservableTree{L}\n\tOps::Vector{Vector{AbstractLocalOperator}}\n\tRefs::Dict{String, Dict}\n\tRootL::InteractionTreeNode\n\tRootR::InteractionTreeNode\nend\n\nSimilar to InteractionTree but specially used for calculation of observables.\n\nConstructors\n\n ObservableTree(L)\n\nInitialize an empty object, where L is the number of sites.\n\n\n\n\n\n","category":"type"},{"location":"lib/ObsTree/#Base.merge!-Tuple{ObservableTree}","page":"Observable Tree","title":"Base.merge!","text":"merge!(Tree::InteractionTree) -> Tree::InteractionTree\n\nMerge interactions with same left or right environment tensor. Symmetrical merging from boundary to bulk is used here, which works well for most cases.\n\n\n\n\n\nmerge!(Tree::ObservableTree) -> Tree::ObservableTree\n\nMerge observables in Tree that share the same parent node to reduce the computation cost of environment tensors. The behavior is similar to merge! for InteractionTree, but some detailed logic is different.\n\n\n\n\n\n merge!(G::ImagTimeProxyGraph;\n      verbose::Int64=0,\n      half::Bool=false) -> nothing\n\nSearch and merge some repeated vertices in the ITP graph G.\n\nKwargs\n\n verbose::Int64 = 0\n\nDisplay the merging process if verbose > 0.\n\n half::Bool = false\n\nOnly execute the left(right) merging for the left(right) half sites if half = true.  \n\n\n\n\n\n","category":"method"},{"location":"lib/ObsTree/#FiniteMPS.treewidth","page":"Observable Tree","title":"FiniteMPS.treewidth","text":"treewidth(Tree::ObservableTree) -> Tuple{Int64, Int64}\n\nReturn the tree width of the left and right trees. \n\n\n\n\n\n","category":"function"},{"location":"lib/ObsTree/#FiniteMPS.addObs!","page":"Observable Tree","title":"FiniteMPS.addObs!","text":"addObs!(Tree::ObservableTree{L},\n\tOp::NTuple{N, AbstractTensorMap},\n\tsi::NTuple{N, Int64},\n\tfermionic::NTuple{N, Bool};\n\tZ = nothing,\n\tpspace = nothing,\n\tname = _default_IntrName(N),\n\tIntrName = prod(string.(name)),\n) -> nothing\n\nAdd an N-site observable to Tree, where the observable is characterized by N-tuples Op, si and fermionic. The implementation and usage is similar to addIntr!, except for the logic to deal with same operator which is added twice.\n\nKwargs\n\nZ::Union{Nothing, AbstractTensorMap, Vector{<:AbstractTensorMap}}\n\nProvide the parity operator to deal with the fermionic anti-commutation relations.If Z == nothing, assume all operators are bosonic. Otherwise, a uniform (single operator) Z::AbstractTensorMap or site-dependent (length L vector) Z::Vector{<:AbstractTensorMap} should be given.\n\npspace::Union{Nothing, VectorSpace, Vector{<:VectorSpace}}\n\nProvide the local Hilbert space (VectorSpace in TensorKit.jl). This is not required in generating Hamiltonian, so the default value is set as nothing. But some processes like generating an identity MPO require this information. In such cases, a uniform or site-dependent (length L vector) pspace should be given.\n\nname::NTuple{N, Union{Symbol, String}}\n\nGive a name of each operator.\n\nIntrName::Union{Symbol, String}\n\nGive a name of the interaction, which is used as the key of Tree.Refs::Dict that stores interaction strengths. The default value is the product of each operator name.\n\n\n\n\n\n","category":"function"},{"location":"lib/ObsTree/#FiniteMPS.calObs!","page":"Observable Tree","title":"FiniteMPS.calObs!","text":"calObs!(Tree::ObservableTree{L},\n\tΨ::AbstractMPS{L},\n\tΦ::AbstractMPS{L} = Ψ;\n\tkwargs...\n) -> TO::TimerOutput\n\nCalculate ⟨Ψ|O|Φ⟩ of all observables O stored in Tree, using bra ⟨Ψ| and ket |Φ⟩.\n\nKwargs\n\nEl::AbstractTensorMap \nEr::AbstractTensorMap\n\nManually set boundary left or right environment tensor. Default is the rank-2 isometry deduced from Ψ and Φ, which may be incorrect if the operators have nontrivial auxiliary spaces. \n\nnormalize::Bool = false\n\nIf 'true', calculate ⟨Ψ|O|Φ⟩/(|Ψ||Φ|) instead of ⟨Ψ|O|Φ⟩.\n\nserial::Bool = false\n\nForce to choose serial mode, usually used when debugging.\n\ndisk::Bool = false\n\nStore environment tensor in disk or not.\n\nmaxsize::Int64 = maximum(treewidth(Tree))\n\nNumber of environment tensors left in memory. Default is the larger one of the width of left tree or right tree. \n\nverbose::Int64 = 0\n\nShow the timer several times if verbose > 0.\n\nshowtimes::Int64 = 10\n\nTimes to show the timer.\n\nGCSpacing::Int64 = 100\n\nThe spacing (count nodes) between two nearest manual GC.gc().\n\nntasks::Int64 = get_num_threads()\n\nNumber of distributed tasks, used in multithreaded mode.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/Hubbard/#Hubbard","page":"Hubbard Model","title":"Hubbard Model","text":"","category":"section"},{"location":"lib/Deprecate/#Deprecate","page":"Deprecate","title":"Deprecate","text":"","category":"section"},{"location":"lib/Deprecate/","page":"Deprecate","title":"Deprecate","text":"The following types and methods are used in some old implementations, which may be deprecated in a future version.","category":"page"},{"location":"lib/Deprecate/#FiniteMPS.LanczosInfo","page":"Deprecate","title":"FiniteMPS.LanczosInfo","text":" struct LanczosInfo\n      converged::Bool\n      normres::Vector{Float64}\n      numiter::Int64\n      numops::Int64\n      a::Vector{Float64}\n      b::Vector{Float64}\n end\n\nSimilar to KrylovKit.ConvergenceInfo but delete residuals to save memory.\n\n\n\n\n\n","category":"type"},{"location":"lib/Deprecate/#FiniteMPS.SparseProjectiveHamiltonian","page":"Deprecate","title":"FiniteMPS.SparseProjectiveHamiltonian","text":" struct SparseProjectiveHamiltonian{N} <: AbstractProjectiveHamiltonian  \n\t  El::SparseLeftTensor\n\t  Er::SparseRightTensor\n\t  H::NTuple{N, SparseMPOTensor}\n\t  si::Vector{Int64}\n\t  validIdx::Vector{Tuple}\n\t  E₀::Float64\n end\n\nN-site projective Hamiltonian, sparse version. Note we shift H to H - E₀ to avoid numerical overflow.\n\nConvention: \t  –               –       –                          – \t |         |         |     |         |          |         | \t El– i – H1 – j –Er    El– i – H1 – j – H2 – k –Er    ... \t |         |         |     |         |          |         | \t  –               –       –                          –\n\nvalidIdx stores all tuples (i, j, ...) which are valid, i.e. all El[i], H1[i, j] and Er[j] are not nothing (N == 1). \n\n\n\n\n\n","category":"type"},{"location":"lib/Deprecate/#FiniteMPS.ProjHam","page":"Deprecate","title":"FiniteMPS.ProjHam","text":" ProjHam(Env::SparseEnvironment, siL::Int64 [, siR::Int64 = siL]; E₀::Number = 0.0)\n\nGeneric constructor for N-site projective Hamiltonian, where N = siR - siL + 1.\n\n ProjHam(Env::SimpleEnvironment, siL::Int64 [, siR::Int64 = siL])\n\nConstruct the special IdentityProjectiveHamiltonian from a simple environment.\n\n\n\n\n\n","category":"function"},{"location":"lib/Deprecate/#FiniteMPS.PreFuseProjectiveHamiltonian","page":"Deprecate","title":"FiniteMPS.PreFuseProjectiveHamiltonian","text":" struct PreFuseProjectiveHamiltonian{N, Tl, Tr} <: AbstractProjectiveHamiltonian \n      El::Tl\n      Er::Tr\n      si::Vector{Int64}\n      E₀::Float64\n end\n\nPrefused N-site projective Hamiltonian. Note El and Er can be a original environment tensor or a prefused one, depending on N. If N == 1, only one of them will be prefused.\n\n\n\n\n\n","category":"type"},{"location":"lib/Deprecate/#FiniteMPS.action0","page":"Deprecate","title":"FiniteMPS.action0","text":" action0(obj::SparseProjectiveHamiltonian{0}, x::MPSTensor{2}; kwargs...) -> ::MPSTensor\n\nAction of 0-site projective Hamiltonian on the rank-2 bond local tensors.\n\n\n\n\n\n","category":"function"},{"location":"lib/Deprecate/#FiniteMPS.action1","page":"Deprecate","title":"FiniteMPS.action1","text":" action1(obj::SparseProjectiveHamiltonian{1}, x::MPSTensor; kwargs...) -> ::MPSTensor\n\nAction of 1-site projective Hamiltonian on the 1-site local tensors.\n\n\n\n\n\n","category":"function"},{"location":"lib/Deprecate/#FiniteMPS.action2","page":"Deprecate","title":"FiniteMPS.action2","text":" action2(obj::SparseProjectiveHamiltonian{2}, x::CompositeMPSTensor{2, T}; kwargs...) -> ::CompositeMPSTensor{2, T}\n\nAction of 2-site projective Hamiltonian on the 2-site local tensors, wrapped by CompositeMPSTensor{2, T} where T<:NTuple{2,MPSTensor}.\n\n action2(obj::IdentityProjectiveHamiltonian{2}, x::CompositeMPSTensor{2, T}; kwargs...) -> ::CompositeMPSTensor{2, T}\n\nSpecial case for IdentityProjectiveHamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"lib/MPS/#MPS-and-MPO","page":"MPS & MPO","title":"MPS & MPO","text":"","category":"section"},{"location":"lib/MPS/","page":"MPS & MPO","title":"MPS & MPO","text":"Wrap MPS and MPO as a vector of tensors together with some information.","category":"page"},{"location":"lib/MPS/#FiniteMPS.AbstractMPS","page":"MPS & MPO","title":"FiniteMPS.AbstractMPS","text":" abstract type AbstractMPS{L}\n\nAbstract type of all MPS/MPO with length L.\n\n\n\n\n\n","category":"type"},{"location":"lib/MPS/#FiniteMPS.DenseMPS","page":"MPS & MPO","title":"FiniteMPS.DenseMPS","text":" abstract type DenseMPS{L, T <:Union{Float64, ComplexF64}} <: AbstractMPS{L}\n\nAbstract type of dense MPS/MPO with length L.\n\n\n\n\n\n","category":"type"},{"location":"lib/MPS/#LinearAlgebra.normalize!-Tuple{DenseMPS}","page":"MPS & MPO","title":"LinearAlgebra.normalize!","text":" normalize!(obj::DenseMPS) -> obj\n\nNormalize a given MPS according to inner-induced norm. \n\nNote we assume the MPS satisfies a canonical form and the center tensor is normalized, hence we only normalize c.\n\n\n\n\n\n","category":"method"},{"location":"lib/MPS/#LinearAlgebra.norm-Tuple{DenseMPS}","page":"MPS & MPO","title":"LinearAlgebra.norm","text":" norm(obj::DenseMPS) -> ::Float64\n\nReturn the inner-induced norm. Note we assume the MPS satisfies a canonical form and the center tensor is normalized, hence the norm is just abs(c).\n\n\n\n\n\n","category":"method"},{"location":"lib/MPS/#FiniteMPS.coef-Tuple{DenseMPS}","page":"MPS & MPO","title":"FiniteMPS.coef","text":" coef(obj::DenseMPS) -> ::F\n\nInterface of DenseMPS, return the global coefficient, where F is the number type of given MPS.\n\n\n\n\n\n","category":"method"},{"location":"lib/MPS/#FiniteMPS.Center-Tuple{DenseMPS}","page":"MPS & MPO","title":"FiniteMPS.Center","text":" Center(obj::DenseMPS) -> Vector (length 2)\n\nInterface of DenseMPS, return the info of canonical center. [a, b] means left-canonical from 1 to a-1 and right-canonical from b+1 to L.\n\n\n\n\n\n","category":"method"},{"location":"lib/MPS/#Base.complex-Tuple{DenseMPS}","page":"MPS & MPO","title":"Base.complex","text":" complex(obj::DenseMPS{L}) -> ::DenseMPS{L, ComplexF64}\n\nReturn a copy of given MPS but with ComplexF64 as basic field.\n\n\n\n\n\n","category":"method"},{"location":"lib/MPS/#FiniteMPS.canonicalize!-Tuple{DenseMPS}","page":"MPS & MPO","title":"FiniteMPS.canonicalize!","text":" canonicalize!(obj::DenseMPS, \n      siL::Int64\n      [, siR::Int64 = siL]; kwargs...) -> obj::DenseMPS\n\nCanonicalize the MPS s.t. all sites ≤ siL are left-canonical, all sites ≥ siR are right-canonical.  \n\nkwargs will be propagated to leftorth and rightorth to determine how to truncate the SVD spectra.\n\n\n\n\n\n canonicalize!(obj::AbstractEnvironment, \n      siL::Int64\n      [, siR::Int64 = siL]; kwargs...) -> obj::AbstractEnvironment\n\nCanonicalize the environment s.t. at least El[i ≤ siL] and Er[i ≥ siR] are valid.\n\nKwargs\n\n free::Bool = true\n\nIf true, call free!(obj) to free the local environment tensors which are no longer required. Details see free!.\n\n\n\n\n\n","category":"method"},{"location":"lib/MPS/#FiniteMPS.AdjointMPS","page":"MPS & MPO","title":"FiniteMPS.AdjointMPS","text":" struct AdjointMPS{L} <: AbstractMPS{L}\n      parent::DenseMPS{L}\n end\n\nLazy wrapper type for adjoint of MPS.\n\n adjoint(::DenseMPS) -> ::AdjointMPS\n adjoint(::AdjointMPS) -> ::DenseMPS\n\nFunctions to be directly propagated to the parent:\n\n lastindex, length, keys, norm, normalize!, Center, iterate, canonicalize!\n\nFunctions to be propagated to the parent with some adaptations:\n\n getindex, setindex!, coef\n\n\n\n\n\n","category":"type"},{"location":"lib/MPS/#FiniteMPS.MPS","page":"MPS & MPO","title":"FiniteMPS.MPS","text":" mutable struct MPS{L, T <:Union{Float64, ComplexF64}, C} <: DenseMPS{L, T}\n      const A::AbstractVector{AbstractMPSTensor}\n      const Center::Vector{Int64} \n      c::T \n end\n\nConcrete type of MPS, where L is the length, T == Float64 or ComplexF64 is the number type of local tensors.\n\nC <: AbstractStoreType is the type to determine the storage of local tensors, usually C == StoreMemory. We can use package SerializedElementArrays to store local tensors in disk, in which case C == StoreDisk.\n\nFields\n\n const A::AbstractVector{AbstractMPSTensor}\n\nLength L vector to store the local tensors. Note the vector A is immutable while the local tensors in it are mutable.\n\n const Center::Vector{Int64}\n\nLength 2 vector to label the canonical form. [a, b] means left-canonical from 1 to a-1 and right-canonical from b+1 to L.\n\n c::T\n\nThe global coefficient, i.e. we represented a MPS with L local tensors and an additional scalar c, in order to avoid too large/small local tensors. \n\nConstructors\n\n MPS{L, T}(A::AbstractVector{<:AbstractMPSTensor}, Center::Vector{Int64} = [1, L], c::T = one(T))\n\nStandard constructor. Note we will promote all local tensors if T == ComplexF64 while the input local tensors in A are of Float64.\n\n MPS(A::AbstractVector{<:AbstractMPSTensor}, args...)\n\nDeduce type parameters via L = length(A) and T = typeof(c).   For default c cases, assume T = Float64 if all local tensors are real, otherwise T = ComplexF64.\n\n MPS(A::AbstractVector{<:AbstractTensorMap}, args...)\n\nAutomatically convert local tensors to warpper type MPSTensor.\n\n MPS{L, T}() \n MPS(L, T = Float64)\n\nInitialize an MPS{L, T} with the local tensors A to be filled. Note we initialize Center = [1, L] and c = one(T).\n\nNewest update, kwargs disk::Bool = false can be added to each constructor to control how to store the local tensors.\n\n\n\n\n\n","category":"type"},{"location":"lib/MPS/#FiniteMPS.randMPS","page":"MPS & MPO","title":"FiniteMPS.randMPS","text":" randMPS([::Type{T},]  \n      pspace::Vector{VectorSpace},\n      aspace::Vector{VectorSpace};\n      kwargs...) -> MPS{L}\n\nGenerate a length L random MPS with given length L vector pspace and aspace. T = Float64(default) or ComplexF64 is the number type. Note the canonical center is initialized to the first site.\n\n randMPS([::Type{T},] L::Int64, pspace::VectorSpace, apsace::VectorSpace; kwargs...) -> MPS{L}\n\nAssume the same pspace and aspace, except for the boundary bond, which is assumed to be trivial.  \n\n\n\n\n\n","category":"function"},{"location":"lib/MPS/#FiniteMPS.MPO","page":"MPS & MPO","title":"FiniteMPS.MPO","text":" mutable struct MPO{L, T <:Union{Float64, ComplexF64}, C} <: DenseMPS{L, T}\n      const A::AbstractVector{AbstractMPSTensor}\n      const Center::Vector{Int64} \n      c::T \n end\n\nAll the fields and constructors are exactly the same to those of MPS, we redefine the type MPO just for using multiple dispacth when implementing the algebra between MPS and MPO. \n\nDetails of constructors please see MPS. \n\n\n\n\n\n","category":"type"},{"location":"lib/MPS/#FiniteMPS.identityMPO","page":"MPS & MPO","title":"FiniteMPS.identityMPO","text":" identityMPO(::Type{T} = Float64, L::Int64, pspace::AbstractVector; kwargs...)\n\nConstruct an identity MPO where the physical spaces are informed by a length L vertor of VectorSpace.\n\n identityMPO(::Type{T} = Float64, L::Int64, pspace::VectorSpace; kwargs...)\n\nAssume the all the physical spaces are the same.\n\n identityMPO(obj::DenseMPS{L, T}; kwargs...)\n\nDeduce the scalar type T and physical spaces from a MPS/MPO.\n\nKwargs\n\n disk::Bool = false\n bspace::VectorSpace\n\nSpace of left boundary bond, default = trivial space.\n\n\n\n\n\n","category":"function"},{"location":"lib/MPS/#FiniteMPS.SparseMPO","page":"MPS & MPO","title":"FiniteMPS.SparseMPO","text":" struct SparseMPO{L} <: AbstractMPS{L}\n\t  A::Vector{SparseMPOTensor}\n end\n\nConcrete type of sparse MPO. \n\nNote an instance of this type is usually a Hamiltonian,  which will not cost too much memory, therefore we always store the local tensors in memory.\n\nConstructors\n\nSparseMPO(A::AbstractVector{SparseMPOTensor})\n\n\n\n\n\n","category":"type"},{"location":"index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"tutorial/Heisenberg/#Heisenberg-Model","page":"Heisenberg Model","title":"Heisenberg Model","text":"","category":"section"},{"location":"lib/Algorithm/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"lib/Algorithm/","page":"Algorithms","title":"Algorithms","text":"Some high level algorithms based on MPS and MPO.","category":"page"},{"location":"lib/Algorithm/#DMRG","page":"Algorithms","title":"DMRG","text":"","category":"section"},{"location":"lib/Algorithm/","page":"Algorithms","title":"Algorithms","text":"Density matrix renormalization group.","category":"page"},{"location":"lib/Algorithm/#FiniteMPS.BondInfo","page":"Algorithms","title":"FiniteMPS.BondInfo","text":" struct BondInfo\n      D::Int64\n      DD::Int64\n      TrunErr::Float64\n      SE::Float64\n end\n\nType for storing the information of a bond.\n\nConstructors\n\n BondInfo(s::AbstractTensorMap, ϵ::Float64 = 0.0)\n\nOuter constructor via giving the s tensor and ϵ form tsvd.\n\n BondInfo(A::AbstractTensorMap, direction::Symbol)\n BondInfo(A::MPSTensor, direction::Symbol)\n\nOuter constructor via giving a tensor A and direction = :L or :R. We cannot get truncation error and singular values hence TrunErr and SE are set to 0.0 and NaN, respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/Algorithm/#FiniteMPS.DMRGInfo","page":"Algorithms","title":"FiniteMPS.DMRGInfo","text":" struct DMRGInfo\n      Eg::Float64\n      Lanczos::LanczosInfo\n      Bond::BondInfo\n end\n\nInformation of each DMRG update.\n\n\n\n\n\n","category":"type"},{"location":"lib/Algorithm/#FiniteMPS.LanczosGS","page":"Algorithms","title":"FiniteMPS.LanczosGS","text":"LanczosGS(f::Function, x₀, args...;\n\tK::Int64 = 32,\n\ttol::Real = 1e-8,\n\tcallback::Union{Nothing, Function} = nothing,\n\tverbose = false\n) -> ϵg::Number, xg::AbstractVector, info::Dict{Symbol, Any}\n\nSolve the ground state problem for a hermitian map x -> f(x, args...) using the Lanczos algorithm. f can be any function as if it acts on x like an hermitian operator and preserves the type of x.\n\nRequired methods\n\nx can be any type as if it behaves like a vector in Hilbert space, i.e. the following methods are implemented:\n\nnormalize!(x)\n\nIn-place normalize x according to the inner-induced norm.\n\nnorm(x)\n\nReturn the inner-induced norm.\n\ninner(x, y)\n\nReturn the inner product ⟨x, y⟩.\n\nadd!(y, x, α)\n\nIn-place add y -> y + αx.\n\nrmul!(x, α)\n\nIn-place multiply x -> αx.\n\nKwargs\n\nK::Int64 = 32\n\nKrylov space dimension.\n\ntol::Real = 1e-8\n\nConvergence tolerance.  \n\ncallback::Union{Nothing, Function} = nothing\n\nA in-placed callback function, applied to x after each iteration.\n\nverbose::Bool = false\n\nIf true, print convergence information.\n\n\n\n\n\n","category":"function"},{"location":"lib/Algorithm/#FiniteMPS.DMRGSweep2!","page":"Algorithms","title":"FiniteMPS.DMRGSweep2!","text":" DMRGSweep2!(Env::SparseEnvironment{L,3,T}, ::SweepDirection; kwargs...) \n      -> info::Vector{DMRGInfo}, Timer::TimerOutput\n\n2-site DMRG sweep from left to right or sweep back from right to left.  \n\nKwargs\n\n K::Int64 = 16\n\nKrylov space dimension.\n\n tol::Real = 1e-8\n\nTolerance for eagerly break in Lanczos iteration.\n\n trunc::TruncationScheme = truncbelow(MPSDefault.tol) & truncdim(MPSDefault.D)\n\nControl the truncation in svd after each 2-site update. Details see tsvd. \n\n GCstep::Bool = false\n\nGC.gc() manually after each step if true.\n\n GCsweep::Bool = false\n\nGC.gc() manually after each (left to right or right to left) sweep if true.  \n\n verbose::Int64 = 0\n\nPrint the TimerOutput after each sweep or each local update if verbose = 1 or 2, respectively.\n\n noise::Real = 0\n\nAdd noise to the 2-site local tensor after each update via applying a random gate to the physical indices. Note this is only a naive implementation, and may not work well for some cases. \n\n\n\n\n\n","category":"function"},{"location":"lib/Algorithm/#FiniteMPS.DMRGSweep1!","page":"Algorithms","title":"FiniteMPS.DMRGSweep1!","text":" DMRGSweep1!(Env::SparseEnvironment{L,3,T}, ::SweepDirection; kwargs...)\n      -> info::Vector{DMRGInfo}, Timer::TimerOutput\n\n1-site DMRG sweep from left to right or sweep back from right to left.  \n\nKwargs\n\n K::Int64 = 16\n\nKrylov space dimension.\n\n tol::Real = 1e-8\n\nTolerance for eagerly break in Lanczos iteration.\n\n GCstep::Bool = false\n\nGC.gc() manually after each step if true.\n\n GCsweep::Bool = false\n\nGC.gc() manually after each (left to right or right to left) sweep if true.   \n\n verbose::Int64 = 0\n\nPrint the TimerOutput after each sweep or each local update if verbose = 1 or 2, respectively.\n\n CBEAlg::CBEAlgorithm = NoCBE()\n\nCBE algorithm for 1-DMRG.\n\n trunc::TruncationScheme = notrunc()\n\nControl the truncation after each update, only used together with CBE. Details see tsvd. \n\n noise::NTuple{2, Float64} = (0.1, 0.0)\n\nAdd noise to the 1-site local tensor after each Lanczos update via expanding the bond and add a random tensor (normal distribution) to it. The first element is the ratio of additional bond dimension (≤ 1.0), the second element is the noise strength.\n\n\n\n\n\n","category":"function"},{"location":"lib/Algorithm/#TDVP","page":"Algorithms","title":"TDVP","text":"","category":"section"},{"location":"lib/Algorithm/","page":"Algorithms","title":"Algorithms","text":"Time-dependent variational principle for both MPS and MPO (viewed as a MPS via Choi isomorphism).","category":"page"},{"location":"lib/Algorithm/","page":"Algorithms","title":"Algorithms","text":"Note the local projective Hamiltonian action in TDVPSweep2! has not been updated to newest implementation. Using 1-TDVP equipped with controlled bond expansion (CBE) is preferred. ","category":"page"},{"location":"lib/Algorithm/#FiniteMPS.TDVPInfo","page":"Algorithms","title":"FiniteMPS.TDVPInfo","text":" struct TDVPInfo{N,T}\n      dt::T\n      Lanczos::LanczosInfo\n      Bond::BondInfo\n end\n\nInformation of each N-site TDVP update.\n\nConstructors\n\n TDVPInfo{N}(dt::Number, Lanczos::LanczosInfo, Bond::BondInfo)\n\n\n\n\n\n","category":"type"},{"location":"lib/Algorithm/#FiniteMPS.LanczosExp","page":"Algorithms","title":"FiniteMPS.LanczosExp","text":"LanczosExp(f::Function, x₀, t::Number, args...;\n\tK::Int64 = 32,\n\ttol::Real = 1e-8,\n\tcallback::Union{Nothing, Function} = nothing,\n\tverbose = false\n) -> exp(At)*x, info::Dict{Symbol, Any}\n\nCompute exp(At)x₀ for a hermitian map A: x -> f(x, args...) using the Lanczos algorithm. f can be any function as if it acts on x like an hermitian operator and preserves the type of x.\n\nRequired methods\n\nx can be any type as if it behaves like a vector in Hilbert space, i.e. the following methods are implemented:\n\neltype(x)\n\nReturn the element type of x, e.g. Float64 or ComplexF64.\n\nnormalize!(x)\n\nIn-place normalize x according to the inner-induced norm.\n\nnorm(x)\n\nReturn the inner-induced norm.\n\ninner(x, y)\n\nReturn the inner product ⟨x, y⟩.\n\nadd!(y, x, α)\n\nIn-place add y -> y + αx.\n\nrmul!(x, α)\n\nIn-place multiply x -> αx.\n\nKwargs\n\nK::Int64 = 32\n\nKrylov space dimension.\n\ntol::Real = 1e-8\n\nConvergence tolerance.  \n\ncallback::Union{Nothing, Function} = nothing\n\nA in-placed callback function, applied to x after each iteration.\n\nverbose::Bool = false\n\nIf true, print convergence information.\n\n\n\n\n\n","category":"function"},{"location":"lib/Algorithm/#FiniteMPS.TDVPSweep2!","page":"Algorithms","title":"FiniteMPS.TDVPSweep2!","text":" TDVPSweep2!(Env::SparseEnvironment{L,3,T},\n      dt::Number,\n      direction::SweepDirection;\n      kwargs...) -> info, TimerSweep\n\nApply left-to-right or right-to-left 2-site TDVP[https://doi.org/10.1103/PhysRevB.94.165116] sweep to perform time evolution for DenseMPS (both MPS and MPO) with step length dt. Env is the 3-layer environment ⟨Ψ|H|Ψ⟩.\n\n TDVPSweep2!(Env::SparseEnvironment{L,3,T}, dt::Number; kwargs...)\n\nWrap TDVPSweep2! with a symmetric integrator, i.e., sweeping from left to right and then from right to left with the same step length dt / 2.\n\nKwargs\n\n krylovalg::KrylovKit.KrylovAlgorithm = TDVPDefaultLanczos\n trunc::TruncationType = truncbelow(MPSDefault.tol) & truncdim(MPSDefault.D)\n GCstep::Bool = false\n GCsweep::Bool = false\n verbose::Int64 = 0\n E_shift::Float64 = 0.0\n\nApply exp(dt(H - E_shift)) to avoid possible Inf in imaginary time evolution. This energy shift is different from E₀ in projective Hamiltonian, the later will give back the shifted energy thus not altering the final result. Note this is a temporary approach, we intend to store log(norm) in MPS to avoid this divergence in the future.\n\n\n\n\n\n","category":"function"},{"location":"lib/Algorithm/#FiniteMPS.TDVPSweep1!","page":"Algorithms","title":"FiniteMPS.TDVPSweep1!","text":" TDVPSweep1!(Env::SparseEnvironment{L,3,T},\n\t  dt::Number,\n\t  direction::SweepDirection;\n\t  kwargs...) -> info, TimerSweep\n\nApply 1-site TDVP[https://doi.org/10.1103/PhysRevB.94.165116] sweep to perform time evolution for DenseMPS (both MPS and MPO) with step length dt. Env is the 3-layer environment ⟨Ψ|H|Ψ⟩.\n\n TDVPSweep1!(Env::SparseEnvironment{L,3,T}, dt::Number; kwargs...)\n\nWrap TDVPSweep1! with a symmetric integrator, i.e., sweeping from left to right and then from right to left with the same step length dt / 2.\n\nKwargs\n\n K::Int64 = 32 \n tol::Float64 = 1e-8\n\nThe maximum Krylov dimension and tolerance in Lanczos exponential method.\n\n trunc::TruncationType = notrunc()\n GCstep::Bool = false\n GCsweep::Bool = false\n verbose::Int64 = 0\n CBEAlg::CBEAlgorithm = NoCBE()\n E_shift::Float64 = 0.0\n\nApply exp(dt(H - E_shift)) to avoid possible Inf in imaginary time evolution. This energy shift is different from E₀ in projective Hamiltonian, the later will give back the shifted energy thus not altering the final result. Note this is a temporary approach, we intend to store log(norm) in MPS to avoid this divergence in the future.\n\n\n\n\n\n","category":"function"},{"location":"lib/Algorithm/#FiniteMPS.TDVPIntegrator","page":"Algorithms","title":"FiniteMPS.TDVPIntegrator","text":" struct TDVPIntegrator{N} \n      dt::NTuple{N, Float64}\n      direction::NTuple{N, SweepDirection}\n end\n\nType of TDVP integrators using composition methods. Note dt is relative, thus sum(dt) == 1.\n\nConstructors\n\n TDVPIntegrator(dt::NTuple{N, Rational}, direction::NTuple{N, SweepDirection})\n\nStandard constructor with checking dt and direction.\n\n TDVPIntegrator(dt::Number...)\n\nAssume direction is repeated as L-R-L-R-..., thus length(dt) must be even.\n\n\n\n\n\n","category":"type"},{"location":"lib/Algorithm/#FiniteMPS.SymmetricIntegrator","page":"Algorithms","title":"FiniteMPS.SymmetricIntegrator","text":" SymmetricIntegrator(p::Int64) -> TDVPIntegrator\n\nConstruct predefined symmetric integrators with p-th order. Only p = 2, 3, 4 are supported.\n\n\n\n\n\n","category":"function"},{"location":"lib/Algorithm/#SETTN","page":"Algorithms","title":"SETTN","text":"","category":"section"},{"location":"lib/Algorithm/","page":"Algorithms","title":"Algorithms","text":"Series-expansion thermal tensor network.","category":"page"},{"location":"lib/Algorithm/#FiniteMPS.SETTN","page":"Algorithms","title":"FiniteMPS.SETTN","text":" SETTN(H::SparseMPO, β::Number; kwargs...) -> ρ::MPO, lsF::Vector{Float64}\n\nUse series-expansion thermal tensor network (SETTN)[https://doi.org/10.1103/PhysRevB.95.161104] method to initialize a high-temperature MPO ρ = e^(-βH/2). Note ρ is unnormalized. The list of free energy F = -lnTr[ρρ^†]/β with different expansion orders is also returned.\n\nKwargs\n\n trunc::TruncationScheme = truncdim(D) (this keyword argument is necessary!) \n disk::Bool = false\n maxorder::Int64 = 4\n tol::Float64 = 1e-8\n bspace::VectorSpace (details please see identityMPO)\n compress::Float64 = 1e-16 (finally compress ρ with `tol = compress`)\n ρ₀::MPO (initial MPO, default = Id)\n\nNote we use mul! and axpby! to implement H^n -> H^(n+1) and ρ -> ρ + (-βH/2)^n / n!, respectively. All kwargs of these two functions are valid and will be propagated to them appropriately.\n\n\n\n\n\n","category":"function"},{"location":"lib/Algorithm/#CBE","page":"Algorithms","title":"CBE","text":"","category":"section"},{"location":"lib/Algorithm/","page":"Algorithms","title":"Algorithms","text":"Controlled bond expansion (CBE). In the current version only a modified (based on rsvd, instead of shrewd selection) CBE is implemented, which is compatible with multi-threading.","category":"page"},{"location":"lib/Algorithm/#FiniteMPS.CBEAlgorithm","page":"Algorithms","title":"FiniteMPS.CBEAlgorithm","text":" abstract type CBEAlgorithm{T <: SweepDirection}\n\nAbstract type of all (controlled bond expansion) CBE algorithms.\n\n\n\n\n\n","category":"type"},{"location":"lib/Algorithm/#FiniteMPS.NoCBE","page":"Algorithms","title":"FiniteMPS.NoCBE","text":" struct NoCBE{T <: SweepDirection} <: CBEAlgorithm{T}\n\n\n\n\n\n","category":"type"},{"location":"lib/Algorithm/#FiniteMPS.FullCBE","page":"Algorithms","title":"FiniteMPS.FullCBE","text":" struct FullCBE{T <: SweepDirection} <: CBEAlgorithm{T} \n      check::Bool\n end\n\nSpecial case of CBE algorithm, directly keep the full bond space, usually used near boundary.\n\nConstructor\n\n FullCBE(direction::SweepDirection = AnyDirection(); check::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"lib/Algorithm/#FiniteMPS.NaiveCBE","page":"Algorithms","title":"FiniteMPS.NaiveCBE","text":" struct NaiveCBE{T<:SweepDirection} <: CBEAlgorithm{T}\n      D::Int64\n      tol::Float64\n      rsvd::Bool\n      check::Bool\n end\n\nAn naive implementation of CBE, where we directly contract the 2-site environment and then perform svd. Note the svd is O(D^3d^3) or O(D^3d^6) for MPS or MPO, respectively, which becomes the bottleneck of the algorithm. Therefore, a random svd is used to reduce the svd cost to O(D^3d) or O(D^3d^2).  \n\nConstructor\n\n NaiveCBE(D::Int64,\n      tol::Float64,\n      direction::SweepDirection = AnyDirection();\n      rsvd::Bool = false,\n      check::Bool = false)\n\n\n\n\n\n","category":"type"},{"location":"lib/Algorithm/#FiniteMPS.CBEInfo","page":"Algorithms","title":"FiniteMPS.CBEInfo","text":" struct CBEInfo{N}\n      Alg::CBEAlgorithm\n      info::NTuple{N, BondInfo}\n      D₀::NTuple{2, Int64}\n      D::NTuple{2, Int64}\n      ϵp::Float64\n      ϵ::Float64\n end\n\nInformation of CBE. Alg is the algorithm used. info contain the truncation info of N times svd. D₀ and D are the initial and final bond dimension, respectively. ϵp is the estimated projection error. ϵ = |Al*Ar - Al_ex*Ar_ex| if calculated (otherwise NaN). \n\n\n\n\n\n","category":"type"},{"location":"lib/Algorithm/#FiniteMPS.CBE","page":"Algorithms","title":"FiniteMPS.CBE","text":" CBE(Al::MPSTensor, Ar::MPSTensor,\n\t  El::SparseLeftTensor, Er::SparseRightTensor,\n\t  Hl::SparseMPOTensor, Hr::SparseMPOTensor,\n\t  Alg::CBEAlgorithm\n\t  ) -> Al_ex::MPSTensor, Ar_ex::MPSTensor, info::CBEInfo, TO::TimerOutput\n\nReturn the two expanded local tensors Al_ex and Ar_ex after CBE.\n\n\n\n\n\n","category":"function"},{"location":"lib/Algorithm/#FiniteMPS.LeftOrthComplement","page":"Algorithms","title":"FiniteMPS.LeftOrthComplement","text":"struct LeftOrthComplement{N}\n\tEl::Vector{AbstractTensorMap}\n\tAl::Vector{AbstractTensorMap}\n\tAl_c::AbstractTensorMap\nend\n\nA concrete type to deal with the left half of the orthogonal complement projector of 1-site tangent space in the 2-site variational space.\n\nConstructors\n\nLeftOrthComplement(El_i::SparseLeftTensor,\n\tAl_c::MPSTensor{R},\n\tHl::SparseMPOTensor,\n\tAl_i::MPSTensor = Al_c)\n\nConstruct the object via providing the initial left environment tensor El_i, the left canonical MPS tensor Al_c, the Hamiltonian MPO tensor Hl, and the initial local tensor at the left site. The initialization process will automatically generate the temporary tensors El and Al that are used in the CBE algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/Algorithm/#FiniteMPS.RightOrthComplement","page":"Algorithms","title":"FiniteMPS.RightOrthComplement","text":"struct RightOrthComplement{N}\n\tEr::Vector{AbstractTensorMap}\n\tAr::Vector{AbstractTensorMap}\n\tAr_c::AbstractTensorMap\nend\n\nA concrete type to deal with the right half of the orthogonal complement projector of 1-site tangent space in the 2-site variational space.\n\nConstructors\n\nRightOrthComplement(Er_i::SparseRightTensor,\n\tAr_c::MPSTensor{R},\n\tHr::SparseMPOTensor,\n\tAr_i::MPSTensor{R} = Ar_c)\n\nConstruct the object via providing the initial right environment tensor Er_i, the right canonical MPS tensor Ar_c, the Hamiltonian MPO tensor Hr, and the initial local tensor at the right site. The initialization process will automatically generate the temporary tensors Er and Ar that are used in the CBE algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/Environment/#Environment","page":"Environment","title":"Environment","text":"","category":"section"},{"location":"lib/Environment/","page":"Environment","title":"Environment","text":"Deal with the left and right environment tensors of multi-layer MPS/MPO structure. ","category":"page"},{"location":"lib/Environment/#FiniteMPS.AbstractEnvironment","page":"Environment","title":"FiniteMPS.AbstractEnvironment","text":" abstract type AbstractEnvironment{L}\n\nAbstract type of all multi-layer environments. \n\n\n\n\n\n","category":"type"},{"location":"lib/Environment/#FiniteMPS.Center-Tuple{AbstractEnvironment}","page":"Environment","title":"FiniteMPS.Center","text":" Center(obj::AbstractEnvironment) -> Vector (length 2)\n\nInterface of environment, return the info of canonical center. Center = [a, b] means El[1:a] and Er[b:end] are valid.\n\n\n\n\n\n","category":"method"},{"location":"lib/Environment/#FiniteMPS.SimpleEnvironment","page":"Environment","title":"FiniteMPS.SimpleEnvironment","text":" struct SimpleEnvironment{L, N, T<:NTuple{N, AbstractMPS{L}}, C<:AbstractStoreType} <: AbstractEnvironment{L}\n      layer::T\n      El::AbstractVector{SimpleLeftTensor}\n      Er::AbstractVector{SimpleRightTensor}\n      Center::Vector{Int64} \n end\n\nType of all environments whose local left/right tensors are simple, i.e. a single tensor instead of a vector storing several tensors.\n\nCenter = [a, b] means El[1:a] and Er[b:end] are valid.\n\n\n\n\n\n","category":"type"},{"location":"lib/Environment/#FiniteMPS.SparseEnvironment","page":"Environment","title":"FiniteMPS.SparseEnvironment","text":" struct SparseEnvironment{L, N, T<:NTuple{N, AbstractMPS{L}}, C<:AbstractStoreType} <: AbstractEnvironment{L}\n      layer::T\n      El::AbstractVector{SparseLeftTensor}\n      Er::AbstractVector{SparseRightTensor}\n      Center::Vector{Int64} \n end\n\nType of all environments whose local left/right tensors are vectors storing several tensors, usually due to a SparseMPO in a layer.\n\nCenter = [a, b] means El[1:a] and Er[b:end] are valid.\n\n\n\n\n\n","category":"type"},{"location":"lib/Environment/#FiniteMPS.Environment","page":"Environment","title":"FiniteMPS.Environment","text":" Environment(M::AbstractMPS{L}...; kwargs...)\n\nGeneric constructor of environments. \n\nGenerate an environment object according to the input MPS/MPO objects. The boundary environment tensor, i.e. El[1] and Er[L] will be initialized. \n\nKwargs\n\n disk::Bool = false\n\nStore the local environment tensor in disk(true) or in memory(false).\n\n El::Union{SimpleLeftTensor, SparseLeftTensor}\n Er::Union{SimpleLeftTensor, SparseLeftTensor}\n\nInitialize boundary El or Er manually. Default value is generated by function _defaultEl or _defaultEr, respectively.\n\n\n\n\n\n","category":"function"},{"location":"lib/Environment/#FiniteMPS.initialize!","page":"Environment","title":"FiniteMPS.initialize!","text":" initialize!(obj::AbstractEnvironment; kwargs...)\n\nInitialize the boundary environment tensors, i.e. El[1] and Er[L]. \n\nKwargs\n\n El::Union{SimpleLeftTensor, SparseLeftTensor}\n Er::Union{SimpleRightTensor, SparseRightTensor}\n\nDirectly give El or Er, otherwise, use _defaultEl or _defaultEr to generate one.\n\n free::Bool = false\n\nIf true, call free!(obj) to free the local environment tensors which are no longer required. Details see free!.\n\n\n\n\n\n","category":"function"},{"location":"lib/Environment/#FiniteMPS.pushleft!","page":"Environment","title":"FiniteMPS.pushleft!","text":" pushleft!(::AbstractEnvironment)\n\nPush left the given environment object, i.e. Center == [i, j] to [i, j - 1].\n\n\n\n\n\n","category":"function"},{"location":"lib/Environment/#FiniteMPS.pushright!","page":"Environment","title":"FiniteMPS.pushright!","text":" pushright!(::AbstractEnvironment)\n\nPush right the given environment object, i.e. Center == [i, j] to [i + 1, j].\n\n\n\n\n\n","category":"function"},{"location":"lib/Environment/#FiniteMPS.canonicalize!-Tuple{AbstractEnvironment}","page":"Environment","title":"FiniteMPS.canonicalize!","text":" canonicalize!(obj::DenseMPS, \n      siL::Int64\n      [, siR::Int64 = siL]; kwargs...) -> obj::DenseMPS\n\nCanonicalize the MPS s.t. all sites ≤ siL are left-canonical, all sites ≥ siR are right-canonical.  \n\nkwargs will be propagated to leftorth and rightorth to determine how to truncate the SVD spectra.\n\n\n\n\n\n canonicalize!(obj::AbstractEnvironment, \n      siL::Int64\n      [, siR::Int64 = siL]; kwargs...) -> obj::AbstractEnvironment\n\nCanonicalize the environment s.t. at least El[i ≤ siL] and Er[i ≥ siR] are valid.\n\nKwargs\n\n free::Bool = true\n\nIf true, call free!(obj) to free the local environment tensors which are no longer required. Details see free!.\n\n\n\n\n\n","category":"method"},{"location":"lib/Environment/#FiniteMPS.free!-Tuple{AbstractEnvironment}","page":"Environment","title":"FiniteMPS.free!","text":" free!(obj::AbstractEnvironment; \n      siL::AbstractVector{Int64} = obj.Center[1] + 1 : L,\n      siR::AbstractVector{Int64} = 1 : obj.Center[2] - 1     \n ) -> nothing\n\nFree the local tensors in El[siL] and Er[siR].\n\n\n\n\n\n","category":"method"},{"location":"lib/Environment/#FiniteMPS.scalar!","page":"Environment","title":"FiniteMPS.scalar!","text":" scalar!(obj::AbstractEnvironment; kwargs...) -> ::Number\n\nFully contract the total tensor network to get a scalar. \n\nNote this may change the Center of the environment obj.\n\nKwargs\n\n normalize::Bool = false\n\nIf true, calculate ⟨Ψ₁|H|Ψ₂⟩/(|Ψ₁||Ψ₂|) instead of ⟨Ψ₁|H|Ψ₂⟩.\n\n split::Bool = false\n\nSplit the value into each contribution of each left boundary environment if true. Thus, return a vector instead of a scalar in this case. \n\n tmp::Bool = false\n\ntmp == true means the environment is temporary, and thus we will free the local environment tensors which are no longer required. \n\n\n\n\n\n","category":"function"},{"location":"lib/Environment/#FiniteMPS.connection!","page":"Environment","title":"FiniteMPS.connection!","text":" connection!(Env1::SparseEnvironment, Env2::SparseEnvironment, ...; \n\t  kwargs...) -> ::Matrix\n\nReturn the connection ⟨∇⟨Hᵢ⟩, ∇⟨Hⱼ⟩⟩ where H₀, H₁, ⋯, Hₙ are the Hamiltonian corresponding to the given environments.\n\nNote this function will move all the canonical centers to the right boundary. \n\nkwargs\n\n moveback::Bool = false\n\nMove the canonical center back to the left boundary if true.\n\n\n\n\n\n","category":"function"},{"location":"lib/Environment/#FiniteMPS.absorb!","page":"Environment","title":"FiniteMPS.absorb!","text":"absorb!(El::SparseLeftTensor, x::MPSTensor{2}) -> nothing\n absorb!(Er::SparseRightTensor, x::MPSTensor{2}) -> nothing\n\nAbsorb a rank-2 bond tensor to a environment tensor.\n\n\n\n\n\n","category":"function"},{"location":"lib/ProjHam/#Projective-Hamiltonian","page":"Projective Hamiltonian","title":"Projective Hamiltonian","text":"","category":"section"},{"location":"lib/ProjHam/","page":"Projective Hamiltonian","title":"Projective Hamiltonian","text":"Local projective Hamiltonian for DMRG or TDVP sweeps.","category":"page"},{"location":"lib/ProjHam/#FiniteMPS.AbstractProjectiveHamiltonian","page":"Projective Hamiltonian","title":"FiniteMPS.AbstractProjectiveHamiltonian","text":" abstract type AbstractProjectiveHamiltonian\n\nAbstract type of all projective Hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"lib/ProjHam/#FiniteMPS.SimpleProjectiveHamiltonian","page":"Projective Hamiltonian","title":"FiniteMPS.SimpleProjectiveHamiltonian","text":"mutable struct SimpleProjectiveHamiltonian{N} <: AbstractProjectiveHamiltonian\n\tEl::LocalLeftTensor\n \tEr::LocalRightTensor\n \tH::NTuple{N, AbstractLocalOperator}\n \tcache::Vector{<:AbstractTensorMap}\nend\n\nConcrete type of simple (i.e. El, H and Er define a single interaction term) N-site projective Hamiltonian.\n\nFields\n\nEl::LocalLeftTensor\nEr::LocalRightTensor\n\nLeft and right environment tensors.\n\nH::NTuple{N, AbstractLocalOperator}\n\nThe N local operators in Hamiltonian that define the interaction term.\n\ncache::Vector{<:AbstractTensorMap}\n\nA cache to store the intermediate tensors when the projective Hamiltonian acts on a state, which will be freed when the object is finalized.\n\nConstructors\n\nSimpleProjectiveHamiltonian(El::LocalLeftTensor, Er::LocalRightTensor, H::AbstractLocalOperator...)\n\nConstruct a simple projective Hamiltonian from El, Er and H, where N is automatically deduced from the length of H.\n\n\n\n\n\n","category":"type"},{"location":"lib/ProjHam/#FiniteMPS.CompositeProjectiveHamiltonian","page":"Projective Hamiltonian","title":"FiniteMPS.CompositeProjectiveHamiltonian","text":"mutable struct CompositeProjectiveHamiltonian{L} <: AbstractProjectiveHamiltonian\n\tPH::Vector{SimpleProjectiveHamiltonian{L}}\n\tE₀::Float64\nend\n\nConcrete type of composite projective Hamiltonian, which is a collection of simple projective Hamiltonians.\n\nFields\n\nPH::Vector{SimpleProjectiveHamiltonian{L}}\n\nA vector that stores all contained simple projective Hamiltonians.\n\nE₀::Float64\n\nThe energy offset. The projective Hamiltonian actually acts on a state as H - E₀, usually used to avoid numerical unstableness in Krylov methods.\n\nConstructors\n\nCompositeProjectiveHamiltonian(El::SparseLeftTensor, Er::SparseRightTensor, H::NTuple{L, SparseMPOTensor}, E₀::Float64 = 0.0)\n\nConstruct a composite projective Hamiltonian from the sparse left and right tensors El, Er and H, which directly provided by a SparseEnvironment.\n\n\n\n\n\n","category":"type"},{"location":"lib/ProjHam/#FiniteMPS.IdentityProjectiveHamiltonian","page":"Projective Hamiltonian","title":"FiniteMPS.IdentityProjectiveHamiltonian","text":"struct IdentityProjectiveHamiltonian{N} <: AbstractProjectiveHamiltonian\n\tEl::SimpleLeftTensor\n\tEr::SimpleRightTensor\n\tsi::Vector{Int64}\nend\n\nSpecial type to deal with the cases which satisfy ⟨Ψ₁|Id|Ψ₂⟩ == ⟨Ψ₁|Ψ₂⟩, thus the environment is a 2-layer simple one.\n\nFields\n\nEl::SimpleLeftTensor\nEr::SimpleRightTensor\n\nLeft and right environment tensors.\n\nsi::Vector{Int64}\n\nA length-2 vector to label the starting and ending sites of the projective Hamiltonian.\n\nConstructors\n\nIdentityProjectiveHamiltonian(El::SimpleLeftTensor, Er::SimpleRightTensor, si::Vector{Int64})\n\nConstruct a projective Hamiltonian that corresponds to an identity operator, where the sites are deduced from si.\n\n\n\n\n\n","category":"type"},{"location":"lib/ProjHam/#FiniteMPS.action!","page":"Projective Hamiltonian","title":"FiniteMPS.action!","text":"action!(x::AbstractMPSTensor,\n\tPH::AbstractProjectiveHamiltonian,\n\tTO::Union{TimerOutput, Nothing} = nothing) -> x\n\nIn-place action of the projective Hamiltonian, write PH * x to x.\n\naction!(y::AbstractMPSTensor,\n\tx::AbstractMPSTensor,\n\tPH::AbstractProjectiveHamiltonian,\n\tTO::Union{TimerOutput, Nothing} = nothing) -> y\n\nIn-place action of the projective Hamiltonian, write PH * x to y with x unmodified. \n\n\n\n\n\n","category":"function"},{"location":"lib/ProjHam/#FiniteMPS.action","page":"Projective Hamiltonian","title":"FiniteMPS.action","text":"action(x::AbstractMPSTensor,\n\tPH::AbstractProjectiveHamiltonian,\n\tTO::Union{TimerOutput, Nothing} = nothing) -> PH * x\n\nCompute the action of the projective Hamiltonian on the MPS tensor PH * x with x unmodified. \n\n\n\n\n\n","category":"function"},{"location":"lib/ITP/#Imaginary-Time-Proxy","page":"Imaginary Time Proxy","title":"Imaginary Time Proxy","text":"","category":"section"},{"location":"lib/ITP/","page":"Imaginary Time Proxy","title":"Imaginary Time Proxy","text":"For computing imaginary time proxies (ITP). Use a graph structure to store terms in the current version, which may be changed to a bi-tree structure in the future.","category":"page"},{"location":"lib/ITP/#FiniteMPS.ImagTimeProxyGraph","page":"Imaginary Time Proxy","title":"FiniteMPS.ImagTimeProxyGraph","text":" mutable struct ImagTimeProxyGraph{L}\n      Ops::Vector{Vector{NTuple{2,AbstractLocalOperator}}} # Ops[si][idx]\n      Refs::Dict{String,Dict}\n      graph::MetaDiGraph{Int64,Float64}\n end\n\nThe concrete type for storing the imaginary time proxy (ITP) to be calculated with a graph structure.\n\nFields\n\n Ops::Vector{Vector{NTuple{2,AbstractLocalOperator}}}\n\nStore the operators in a sparse way. Ops[si][idx] stores the idx-th operator on site si.\n\n Refs::Dict{String,Dict}\n\nStore the references of the values to be calculated. Refs[ITPname][si] stores the reference to the value of ITPname with the site indices si.\n\n graph::MetaDiGraph{Int64,Float64}\n\nThe graph with the ITP information binding to its vertices and edges, provided by MetaGraphs.jl[https://github.com/JuliaGraphs/MetaGraphs.jl].\n\nConstructors\n\n ImagTimeProxyGraph(L::Int64) -> ::ImagTimeProxyGraph{L}\n\nThe only constructor for ImagTimeProxyGraph, which creates an empty graph with L sites. The ITP terms can be added to it by methods like addITP2! or addITP4! later.  \n\n\n\n\n\n","category":"type"},{"location":"lib/ITP/#Base.merge!-Tuple{ImagTimeProxyGraph}","page":"Imaginary Time Proxy","title":"Base.merge!","text":"merge!(Tree::InteractionTree) -> Tree::InteractionTree\n\nMerge interactions with same left or right environment tensor. Symmetrical merging from boundary to bulk is used here, which works well for most cases.\n\n\n\n\n\nmerge!(Tree::ObservableTree) -> Tree::ObservableTree\n\nMerge observables in Tree that share the same parent node to reduce the computation cost of environment tensors. The behavior is similar to merge! for InteractionTree, but some detailed logic is different.\n\n\n\n\n\n merge!(G::ImagTimeProxyGraph;\n      verbose::Int64=0,\n      half::Bool=false) -> nothing\n\nSearch and merge some repeated vertices in the ITP graph G.\n\nKwargs\n\n verbose::Int64 = 0\n\nDisplay the merging process if verbose > 0.\n\n half::Bool = false\n\nOnly execute the left(right) merging for the left(right) half sites if half = true.  \n\n\n\n\n\n","category":"method"},{"location":"lib/ITP/#FiniteMPS.addITP2!","page":"Imaginary Time Proxy","title":"FiniteMPS.addITP2!","text":" addITP2!(G::ImagTimeProxyGraph,\n      Op::NTuple{2,AbstractTensorMap},\n      si::NTuple{2,Int64},\n      Opname::NTuple{2,Union{Symbol,String}},\n      ValueType::Type{<:Number}=Number;\n      ITPname::Union{Symbol,String}=prod(string.(Opname)),\n      Z::Union{Nothing,AbstractTensorMap}=nothing,\n      merge::Bool=true\n ) -> nothing\n\nAdd a two-site term A(β/2)B to the ITP graph. If Z is given, assume each operator is fermionic.\n\n\n\n\n\n","category":"function"},{"location":"lib/ITP/#FiniteMPS.addITP4!","page":"Imaginary Time Proxy","title":"FiniteMPS.addITP4!","text":" addITP4!(G::ImagTimeProxyGraph,\n      Op::NTuple{4,AbstractTensorMap},\n      si::NTuple{4,Int64},\n      Opname::NTuple{4,Union{Symbol,String}},\n      ValueType::Type{<:Number}=Number;\n      ITPname::Union{Symbol,String}=prod(string.(Opname)),\n      Z::Union{Nothing,AbstractTensorMap}=nothing,\n      merge::Bool=true\n ) -> nothing\n\nAdd a 4-site term A(β/2)B(β/2)CD) to the ITP graph. If Z is given, assume each operator is fermionic. \n\n\n\n\n\n","category":"function"},{"location":"lib/ITP/#FiniteMPS.calITP!","page":"Imaginary Time Proxy","title":"FiniteMPS.calITP!","text":" calITP!(G::ImagTimeProxyGraph, ρ::MPO; kwargs...) -> ::TimerOutput\n\nCalculate the values of ITP stroed in graph G and assign the results to G.Refs. Return the TimerOutput object which collects the time cost.\n\nKwargs\n\n serial::Bool = false\n\nForce to compute in serial mode, usually used for debugging.\n\n GCspacing::Int64 = 100\n\nThe spacing of manual garbage collection.\n\n verbose::Int64 = 0\n\nDisplay the timer outputs during the calculation if verbose > 0.\n\n showtimes::Int64 = 100\n\nThe number of times to show the timer outputs.\n\n ntasks::Int64 = get_num_threads_julia() - 1\n\nThe number of tasks to be used in multi-threading mode.\n\n disk::Bool = false\n\nStore the environment tensors in disk if true.\n\n maxdegree::Int64 = 4\n\nThis argument is only used if disk=true. The environment tensor in a vectex will be stored in disk only if its degree < maxdegree, otherwise it will be left in memory to avoid frequent disk I/O.\n\n\n\n\n\n","category":"function"},{"location":"lib/ITP/#Base.convert","page":"Imaginary Time Proxy","title":"Base.convert","text":"convert(T::Type, Tree::ObservableTree; kwargs...)\n\nCollect the observables from the tree and store them in a dictionary or a named tuple. Current valid types are Dict and NamedTuple.  \n\n\n\n\n\nconvert(T::Type, G::ImagTimeProxyGraph; kwargs...)\n\nCollect the observables from the graph G and store them in a dictionary or a named tuple. Current valid types are Dict and NamedTuple.  \n\n\n\n\n\n","category":"function"},{"location":"lib/Algebra/#MPS-and-MPO-Algebra","page":"MPS & MPO Algebra","title":"MPS & MPO Algebra","text":"","category":"section"},{"location":"lib/Algebra/","page":"MPS & MPO Algebra","title":"MPS & MPO Algebra","text":"The algebra operations for MPS and MPO. ","category":"page"},{"location":"lib/Algebra/#VectorInterface.inner-Tuple{DenseMPS}","page":"MPS & MPO Algebra","title":"VectorInterface.inner","text":" inner(A::DenseMPS, B::DenseMPS)\n\nReturn the inner product ⟨A, B⟩ between MPS/MPO A and B.\n\n\n\n\n\n","category":"method"},{"location":"lib/Algebra/#LinearAlgebra.mul!-Tuple{DenseMPS}","page":"MPS & MPO Algebra","title":"LinearAlgebra.mul!","text":"mul!(C::DenseMPS, A::SparseMPO, B::DenseMPS, α::Number, β::Number; kwargs...)\n\nCompute C = α A*B + β C variationally via 2-site update, where A is a sparse MPO, B and C are dense MPS/MPO. Note 'B' cannot reference to the same MPS/MPO with C.  \n\nmul!(C::DenseMPS, A::SparseMPO, B::DenseMPS; kwargs...)\n\nCompute C = A*B by letting α = 1 and β = 0.\n\nKwargs\n\n trunc::TruncationScheme = truncbelow(MPSDefault.tol) & truncdim(MPSDefault.D)\n GCstep::Bool = false\n GCsweep::Bool = false\n maxiter::Int64 = 8\n disk::Bool = false\n tol::Float64 = 1e-8\n verbose::Int64 = 0\n CBEAlg::CBEAlgorithm = NoCBE()\n lsnoise::AbstractVector{Float64} = Float64[]\n\nNote CBE can only be used when α ≠ 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/Algebra/#LinearAlgebra.rmul!","page":"MPS & MPO Algebra","title":"LinearAlgebra.rmul!","text":"rmul!(A::DenseMPS, b::Number)\n\nIn-place multiplication A -> b*A where b is a scalar.\n\n\n\n\n\n","category":"function"},{"location":"lib/Algebra/#LinearAlgebra.axpby!","page":"MPS & MPO Algebra","title":"LinearAlgebra.axpby!","text":" axpby!(α::Number, x::DenseMPS, β::Number, y::DenseMPS; kwargs...)\n\nCompute y = α*x + β*y variationally via 2-site update, where x and y are dense MPS/MPO. Note 'x' cannot reference to the same MPS/MPO with y.  \n\nKwargs\n\n trunc::TruncationScheme = truncbelow(MPSDefault.tol) & truncdim(MPSDefault.D)\n GCstep::Bool = false\n GCsweep::Bool = false\n maxiter::Int64 = 8\n disk::Bool = false\n tol::Float64 = 1e-8\n verbose::Int64 = 0\n lsnoise::AbstractVector{Float64} = Float64[]\n\n\n\n\n\n","category":"function"},{"location":"lib/TensorWrappers/#Tensor-Wrappers","page":"Tensor Wrappers","title":"Tensor Wrappers","text":"","category":"section"},{"location":"lib/TensorWrappers/","page":"Tensor Wrappers","title":"Tensor Wrappers","text":"Wrap pure TensorMap in TensorKit.jl for multiple dispatch. ","category":"page"},{"location":"lib/TensorWrappers/#FiniteMPS.AbstractTensorWrapper","page":"Tensor Wrappers","title":"FiniteMPS.AbstractTensorWrapper","text":" abstract type AbstractTensorWrapper\n\nWrapper type for classifying different Tensors.\n\nNote each concrete subtype must have a field A::AbstractTensorMap to save the Tensor.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.AbstractMPSTensor","page":"Tensor Wrappers","title":"FiniteMPS.AbstractMPSTensor","text":"abstract type AbstractMPSTensor <: AbstractTensorWrapper\n\nElements of MPS, note a MPO is nothing but a MPS with rank-4 tensors, hence we using this type to deal with both MPS and MPO    \n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.MPSTensor","page":"Tensor Wrappers","title":"FiniteMPS.MPSTensor","text":" struct MPSTensor{R} <: AbstractMPSTensor\n      A::AbstractTensorMap\n end\n\nWrapper type for rank-R MPS local tensors.\n\nConvention (' marks codomain): \n\n      3 ... (R-1)\n      \\ | /  \n 1'--   A  ---R         1'-- A -- 2\n        | \n        2'\n\nIn particular, R == 2 for bond tensor.\n\nConstructors\n\n MPSTensor(::AbstractTensorMap) \n MPSTensor{R}(::AbstractTensorMap)\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.CompositeMPSTensor","page":"Tensor Wrappers","title":"FiniteMPS.CompositeMPSTensor","text":" struct CompositeMPSTensor{N, T <: NTuple{N, MPSTensor}} <: AbstractMPSTensor\n      A::AbstractTensorMap\n end\n\nWrapper type for multi-site local tensors.\n\nThe 2nd parameter indicates the types of the N original on-site tensors.\n\nConstructors\n\n CompositeMPSTensor{N, T}(::AbstractTensorMap) where T <: NTuple{N, MPSTensor}\n\nDirectly construct.\n\n CompositeMPSTensor(::NTuple{N, MPSTensor})\n CompositeMPSTensor(::MPSTensor, ::MPSTensor, ...)\n\nContract N on-site tensors to get the N-site tensor. \n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.AdjointMPSTensor","page":"Tensor Wrappers","title":"FiniteMPS.AdjointMPSTensor","text":" struct AdjointMPSTensor{R} <: AbstractMPSTensor\n      A::AbstractTensorMap\n end\n\nLazy wrapper type for tensors of adjoint MPS.  \n\n adjoint(::MPSTensor) -> ::AdjointMPSTensor\n adjoint(::AdjointMPSTensor) -> ::MPSTensor\n\nConvention (' marks codomain): \n\n                   3              4                   R\n                   |              |                   |\n 2-- A --1'     2--A--1'       3--A--2'       (R-1)-- A  --(R-2)'        \n                                  |                 / | \\\n                                  1'              1' ... (R-3)'\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.AbstractEnvironmentTensor","page":"Tensor Wrappers","title":"FiniteMPS.AbstractEnvironmentTensor","text":" abstract type AbstractEnvironmentTensor <: AbstractTensorWrapper\n\nWrapper type for left and right environment tensors.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.LocalLeftTensor","page":"Tensor Wrappers","title":"FiniteMPS.LocalLeftTensor","text":" struct LocalLeftTensor{R} <: AbstractEnvironmentTensor\n\t  A::AbstractTensorMap\n\t  tag::NTuple{R, String}\n end\n\nWrapper type for rank-R left environment tensor, with an additional field tag to distinguish legs of different channels.\n\nConvention (' marks codomain):\n\n  --R\n |\n | --R-1(') \n El  ⋮\n | --2(')\n |\n  --1'\n\nConstructors\n\n LocalLeftTensor(A::AbstractTensorMap [, tag::NTuple{R, String}])\n\nDefault tag = (\"\", \"\", ..., \"\").\n\n LocalLeftTensor{R}(A::AbstractTensorMap)\n\nUsed for automatic converting, only support default tag.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.LocalRightTensor","page":"Tensor Wrappers","title":"FiniteMPS.LocalRightTensor","text":" struct LocalRightTensor{R} <: AbstractEnvironmentTensor\n\t  A::AbstractTensorMap\n\t  tag::NTuple{R, String}\n end\n\nWrapper type for rank-R right environment tensor, with an additional field tag to distinguish legs of different channels.\n\nConvention (' marks codomain):\n\n\t 1'--\n\t\t |\n   2(')--| \n   ⋮     Er  \n R-1(')--| \n\t\t |\n\t  R--\n\nConstructors\n\n LocalRigthTensor(A::AbstractTensorMap [, tag::NTuple{R, String}])\n\nDefault tag = (\"\", \"\", ..., \"\").\n\n LocalRightTensor{R}(A::AbstractTensorMap)\n\nUsed for automatic converting, only support default tag.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.SimpleLeftTensor","page":"Tensor Wrappers","title":"FiniteMPS.SimpleLeftTensor","text":" const SimpleLeftTensor = Union{Nothing, LocalLeftTensor}\n\nType of left environment tensor of simple MPO, i.e. a channel of sparse MPO.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.SimpleRightTensor","page":"Tensor Wrappers","title":"FiniteMPS.SimpleRightTensor","text":" const SimpleRightTensor = Union{Nothing, LocalRightTensor}\n\nType of right environment tensor of simple MPO, i.e. a channel of sparse MPO.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.SparseLeftTensor","page":"Tensor Wrappers","title":"FiniteMPS.SparseLeftTensor","text":" const SparseLeftTensor = Vector{SimpleLeftTensor}\n\nType of left environment tensor of sparse MPO.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.SparseRightTensor","page":"Tensor Wrappers","title":"FiniteMPS.SparseRightTensor","text":" const SparseRightTensor = Vector{SimpleRightTensor}\n\nType of right environment tensor of sparse MPO.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.AbstractLocalOperator","page":"Tensor Wrappers","title":"FiniteMPS.AbstractLocalOperator","text":" abstract type AbstractLocalOperator <: AbstractTensorWrapper\n\nWrapper type for classifying differnet local operators in order to accelerate contractions.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.IdentityOperator","page":"Tensor Wrappers","title":"FiniteMPS.IdentityOperator","text":" mutable struct IdentityOperator <: AbstractLocalOperator\n\t  pspace::VectorSpace\n\t  aspace::VectorSpace\n\t  si::Int64\n\t  strength::Ref{Number}\n end\n\nLazy type of identity operator, used for skipping some tensor contractions.\n\nConstructors\n\n IdentityOperator(pspace::VectorSpace, aspace::VectorSpace, si::Int64, strength::Ref{Number} = Ref{Number}(NaN))\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.tag2Tuple","page":"Tensor Wrappers","title":"FiniteMPS.tag2Tuple","text":" const tag2Tuple{R₁,R₂} = Tuple{NTuple{R₁,String}, NTuple{R₂,String}}\n\nType of field tag of LocalOperator.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.LocalOperator","page":"Tensor Wrappers","title":"FiniteMPS.LocalOperator","text":" mutable struct LocalOperator{R₁,R₂} <: AbstractLocalOperator\n\t  A::AbstractTensorMap\n\t  name::String\n\t  si::Int64\n\t  fermionic::Bool\n\t  strength::Ref{Number}\n\t  tag::tag2Tuple{R₁,R₂}  \n end\n\nWarpper type for local operators, the building blocks of sparse MPO. \n\nR₁ and R₂ indicate the rank corresponding to codomain and domain, respectively.\n\nWarning: this warpper type does not support automatic converting.\n\nConvention (' marks codomain): \n\n 2      2          3         3\n |      |          |         |\n A      A--3   1'--A     1'--A--4               \n |      |          |         |\n 1'     1'         2'        2'\n\nConstructors\n\n LocalOperator(O::AbstractTensorMap,\n\t  name::Union{String,Symbol},\n\t  si::Int64,\n\t  fermionic::Bool,\n\t  [,strength::Ref{Number} = Ref{Number}(NaN)]\n\t  [, tag::tag2Tuple{R₁,R₂}];\n\t  swap::Bool=false,\n\t  aspace::Tuple{VectorSpace, VectorSpace} = Tuple(fill(trivial(codomain(O)[1]), 2)))\n\nDefault tag: \"phys\" for physical indices and name for virtual indices.  \n\nIf swap == ture, it will swap the left and right virtual indices.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.StringOperator","page":"Tensor Wrappers","title":"FiniteMPS.StringOperator","text":" mutable struct StringOperator\n      Ops::Vector{AbstractLocalOperator}\n      strength::Number\n end\n\nConcrete type for an arbitrary string operator. The Ops field stores the local operators and strength is the overall strength.\n\nConstructor\n\n StringOperator(Ops::AbstractVector{<:AbstractLocalOperator}, strength::Number = 1.0) \n StringOperator(Ops::AbstractLocalOperator..., strength::Number = 1.0)\n\nkey methods\n\n sort!(Ops::StringOperator)\n\nSort the operators by their site index in ascending order. Note the fermionic sign will be considered if necessary and will be absorbed into the strength.\n\n reduce!(Ops::StringOperator)\n\nReduce the string operator to a shorter one by numerically performing the composition of operators at the same site. Note this function can only be applied to a sorted string operator.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.SparseMPOTensor","page":"Tensor Wrappers","title":"FiniteMPS.SparseMPOTensor","text":" const SparseMPOTensor = Matrix{Union{Nothing, AbstractLocalOperator}}\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.AbstractStoreType","page":"Tensor Wrappers","title":"FiniteMPS.AbstractStoreType","text":" abstract type AbstractStoreType\n\nOnly has 2 concrete types StoreMemory and StoreDisk, to determine how the collections such as MPS, MPO and  Environment store the local tensors.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.StoreMemory","page":"Tensor Wrappers","title":"FiniteMPS.StoreMemory","text":" struct StoreMemory <: AbstractStoreType\n\nTell the collection to store local tensors in memory.\n\n\n\n\n\n","category":"type"},{"location":"lib/TensorWrappers/#FiniteMPS.StoreDisk","page":"Tensor Wrappers","title":"FiniteMPS.StoreDisk","text":" struct StoreDisk <: AbstractStoreType\n\nTell the collection to store local tensors in disk.\n\n\n\n\n\n","category":"type"},{"location":"localspace/Spin/#Spin","page":"Spin","title":"Spin","text":"","category":"section"},{"location":"localspace/Spin/","page":"Spin","title":"Spin","text":"Predefined local spaces for spin systems.","category":"page"},{"location":"localspace/Spin/#FiniteMPS.SU₂Spin","page":"Spin","title":"FiniteMPS.SU₂Spin","text":" module SU₂Spin\n\nPrepare the local space of SU₂ spin-1/2.\n\nFields\n\n pspace::VectorSpace\n\nLocal d = 2 Hilbert space.\n\n SS::NTuple{2, TensorMap}\n\nTwo rank-3 operators of Heisenberg S⋅S interaction.\n\n\n\n\n\n","category":"module"},{"location":"localspace/Spin/#FiniteMPS.SU2Spin","page":"Spin","title":"FiniteMPS.SU2Spin","text":" const SU2Spin = SU₂Spin\n\n\n\n\n\n","category":"module"},{"location":"localspace/Spin/#FiniteMPS.U₁Spin","page":"Spin","title":"FiniteMPS.U₁Spin","text":" module U₁Spin\n\nPrepare the local space of U₁ spin-1/2.\n\nFields\n\n pspace::VectorSpace\n\nLocal d = 2 Hilbert space.\n\nSz::TensorMap\n\nRank-2 spin-z operator Sz = (n↑ - n↓)/2.\n\nS₊₋::NTuple{2, TensorMap}\nS₋₊::NTuple{2, TensorMap}\n\nTwo rank-3 operators of S₊₋ and S₋₊ interaction. Note Heisenberg S⋅S = SzSz + (S₊₋ + S₋₊)/2.\n\n\n\n\n\n","category":"module"},{"location":"localspace/Spin/#FiniteMPS.U1Spin","page":"Spin","title":"FiniteMPS.U1Spin","text":" module U₁Spin\n\nPrepare the local space of U₁ spin-1/2.\n\nFields\n\n pspace::VectorSpace\n\nLocal d = 2 Hilbert space.\n\nSz::TensorMap\n\nRank-2 spin-z operator Sz = (n↑ - n↓)/2.\n\nS₊₋::NTuple{2, TensorMap}\nS₋₊::NTuple{2, TensorMap}\n\nTwo rank-3 operators of S₊₋ and S₋₊ interaction. Note Heisenberg S⋅S = SzSz + (S₊₋ + S₋₊)/2.\n\n\n\n\n\n","category":"module"},{"location":"localspace/Spin/#FiniteMPS.NoSymSpinOneHalf","page":"Spin","title":"FiniteMPS.NoSymSpinOneHalf","text":" module NoSymSpinOneHalf\n\nPrepare the local space of U₁ spin-1/2. Basis convention is {|↑⟩, |↓⟩}.\n\nFields\n\n pspace::VectorSpace\n\nLocal d = 2 Hilbert space.\n\nSz::TensorMap\nSx::TensorMap\nSy::TensorMap\n\nRank-2 spin-1/2 operators.\n\nS₊::TensorMap\n\nRank-2 spin-plus operator S₊ = Sx + iSy.     S₋::TensorMap Rank-2 spin-minus operator S₋ = Sx - iSy.\n\n\n\n\n\n","category":"module"},{"location":"lib/IntrTree/#Interaction-Tree","page":"Interaction Tree","title":"Interaction Tree","text":"","category":"section"},{"location":"lib/IntrTree/","page":"Interaction Tree","title":"Interaction Tree","text":"Use a bi-tree structure to store the interactions and generate sparse Hamiltonian MPO.","category":"page"},{"location":"lib/IntrTree/#FiniteMPS.AbstractInteractionIterator","page":"Interaction Tree","title":"FiniteMPS.AbstractInteractionIterator","text":" abstract type AbstractInteractionIterator{L}\n\nThe abstract type for the iterator of interaction terms. All the concrete subtypes should implement the iterate method so that the following usages are both valid where  Ops is an instance of AbstractInteractionIterator.\n\nfor O in Ops\n     # the i-th loop will give the i-th LocalOperator\nend\n\ncollect(Ops) # return the vector of all LocalOperators \n\n\n\n\n\n","category":"type"},{"location":"lib/IntrTree/#FiniteMPS.OnSiteInteractionIterator","page":"Interaction Tree","title":"FiniteMPS.OnSiteInteractionIterator","text":" struct OnSiteInteractionIterator{L, T} <: AbstractInteractionIterator{L}\n      Op::AbstractLocalOperator\n      Z::T\n end\n\nThe iterator for on-site terms such as bosonic n_i or fermionic c_i together with its Jordan-Wigner stringZ_{i+1} Z_{i+2} ... Z_{L}.\n\nFields\n\n Op::AbstractLocalOperator\n\nThe local operator which tells both the operator and its site index.\n\n Z::Nothing\n\nFor bosonic operators.      Z::AbstractTensorMap For fermionic operators. Assume all sites are fermionic therefore each site after Op will give Z operator.      Z::AbstractVector{<:AbstractTensorMap} Directly give the Z operator for each site to deal with the systems mixed with bosons and fermions.\n\nConstructors\n\n OnSiteInteractionIterator{L}(Op::AbstractLocalOperator, Z::T) where {L, T}\n\nDirect constructor.\n\n OnSiteInteractionIterator{L}(Op::AbstractTensorMap,\n      name::Union{String, Symbol},\n      si::Int64;\n      swap::Bool=false,\n      Z=nothing)\n\nGenerate the LocalOperator object with Op, name, si and kwarg swap, details please see the constructors of LocalOperator. \n\n\n\n\n\n","category":"type"},{"location":"lib/IntrTree/#FiniteMPS.TwoSiteInteractionIterator","page":"Interaction Tree","title":"FiniteMPS.TwoSiteInteractionIterator","text":" struct TwoSiteInteractionIterator{L, T} <: AbstractInteractionIterator{L}\n      O₁::AbstractLocalOperator\n      O₂::AbstractLocalOperator\n      Z::T\n end\n\nThe iterator for two-site terms such as bosonic n_i n_j or fermionic c_i c_j together with its Jordan-Wigner string Z_{i+1} Z_{i+2} ... Z_{j}.\n\nNote the two site indices can be in both ascending and descending order but should not be the same. For the latter case, please use OnSiteInteractionIterator to get an on-site term instead.\n\nFields\n\n O₁::AbstractLocalOperator\n O₂::AbstractLocalOperator\n\nThe local operators.\n\n Z::Nothing\n\nFor bosonic operators.      Z::AbstractTensorMap For fermionic operators. Note we assume both O₁ and O₂ are fermionic operators if Z ≠ nothing.       Z::AbstractVector{<:AbstractTensorMap} Directly give the Z operator for each site to deal with the systems mixed with bosons and fermions.\n\nConstructors\n\n TwoSiteInteractionIterator{L}(O₁::AbstractLocalOperator, O₂::AbstractLocalOperator, Z::T) where {L, T}\n\nDirect constructor.\n\n TwoSiteInteractionIterator{L}(Op::NTuple{2, AbstractTensorMap},\n      name::NTuple{2, Union{String, Symbol}},\n      si::NTuple{2, Int64};\n      convertRight::Bool=false,\n      Z=nothing)\n\nGenerate the LocalOperator objects with 2-tuples Op, name and si. If convertRight == true, convert the the second operator (with larger site index, can be O₁ or O₂) to a right one (i.e. only have left horizontal leg), which is used to uniquely determine the contraction when calculating ITP. \n\n\n\n\n\n","category":"type"},{"location":"lib/IntrTree/#FiniteMPS.ArbitraryInteractionIterator","page":"Interaction Tree","title":"FiniteMPS.ArbitraryInteractionIterator","text":" ArbitraryInteractionIterator{L} <: AbstractInteractionIterator{L}\n      Ops::Vector{<:AbstractLocalOperator}\n      Z::Union{Nothing, AbstractTensorMap, AbstractVector{<:AbstractTensorMap}}\n      pspace::Union{Nothing, VectorSpace, Vector{<:VectorSpace}}\n end\n\nThe iterator for an arbitrary interaction term. \n\nFields\n\n Ops::Vector{<:AbstractLocalOperator}\n\nA vector to store the local operators, length(Ops) == N means a N-site interaction term.\n\n Z::Union{Nothing, AbstractTensorMap, AbstractVector{<:AbstractTensorMap}}\n pspace::Union{Nothing, VectorSpace, Vector{<:VectorSpace}}\n\nProvide the fermion parity operator Z and the local physical space pspace. Assume a site-independent Z or pspace if a single object is provided, otherwise, a length-L vector is expected to deal with the site-dependent cases.  \n\nConstructors\n\n ArbitraryInteractionIterator{L}(Ops::Vector{<:AbstractLocalOperator},\n      Z::Union{Nothing, AbstractTensorMap, AbstractVector{<:AbstractTensorMap}},\n      pspace::Union{Nothing, VectorSpace, Vector{<:VectorSpace}} = nothing)\n\nThe direct constructor. \n\n\n\n\n\n","category":"type"},{"location":"lib/IntrTree/#FiniteMPS.InteractionChannel","page":"Interaction Tree","title":"FiniteMPS.InteractionChannel","text":"mutable struct InteractionChannel{T}\n\tOps::Vector{Int64}\n\tref::Ref\n\tLeafL::T\n\tLeafR::T\n\tpreserve::Bool\nend\n\nA concrete type for labeling an interaction channel in an InteractionTree.\n\nFields\n\nOps::Vector{Int64}\n\nStores the indices of local operators.\n\nref::Ref\n\nRef for the interaction strength.\n\nLeafL::T\nLeafR::T\n\nThe left and right leaf nodes. \n\npreserve::Bool\n\nIf true, the channel will not be merged so that the interaction strength can be dynamical tuned via Ref.\n\nConstructors\n\nInteractionChannel(Ops::Vector{Int64},\n\tref::Ref,\n\tLeafL::T,\n\tLeafR::T,\n\tpreserve::Bool = false) -> InteractionChannel{T}\n\n\n\n\n\n","category":"type"},{"location":"lib/IntrTree/#FiniteMPS.InteractionTreeNode","page":"Interaction Tree","title":"FiniteMPS.InteractionTreeNode","text":"mutable struct InteractionTreeNode \n\tOp::NTuple{2, Int64}\n\tparent::Union{Nothing, InteractionTreeNode}\n\tchildren::Vector{InteractionTreeNode}\n\tIntrs::Vector{InteractionChannel}\nend\n\nConcrete type for a node of InteractionTree.\n\nFields\n\nOp::NTuple{2, Int64}\n\n(si, idx) to label the idx-st operator at site si.\n\nparent::Union{Nothing, InteractionTreeNode}\nchildren::Vector{InteractionTreeNode}\n\nThe parent node and children nodes.\n\nIntrs::Vector{InteractionChannel}\n\nStores all interaction channels linked to this node.\n\nConstructors\n\nInteractionTreeNode(Op::NTuple{2, Int64},\n\tparent::Union{Nothing, InteractionTreeNode},\n\tchildren::Vector{InteractionTreeNode} = InteractionTreeNode[],\n\tIntrs::Vector{InteractionChannel} = InteractionChannel[]\n\t) -> InteractionTreeNode\n\n\n\n\n\n","category":"type"},{"location":"lib/IntrTree/#FiniteMPS.InteractionTree","page":"Interaction Tree","title":"FiniteMPS.InteractionTree","text":"mutable struct InteractionTree{L}\n\tOps::Vector{Vector{AbstractLocalOperator}}\n\tRefs::Dict{String, Dict}\n\tRootL::InteractionTreeNode\n\tRootR::InteractionTreeNode\nend\n\nImplementation of a bi-tree structure for storing all interactions in a L-site Hamiltonian.\n\nFields\n\nOps::Vector{Vector{AbstractLocalOperator}}\n\nStores all concrete local operators used at each site, Ops[si][idx] is the idx-st operator at site si.\n\nRefs::Dict{String, Dict}\n\nA dictionary to store all interactions strength. Refs[name] is a dictionary (i, j, ...) => Ref, where Ref[] is the strength of this interaction term with site indices i, j, ....\n\nRootL::InteractionTreeNode\nRootR::InteractionTreeNode\n\nThe root node of left (from the first site) or right (from the last site) tree. \n\nConstructors\n\nInteractionTree(L::Int64) -> ::InteractionTree{L}\n\nConstruct an empty InteractionTree.\n\n\n\n\n\n","category":"type"},{"location":"lib/IntrTree/#Base.merge!-Tuple{InteractionTree}","page":"Interaction Tree","title":"Base.merge!","text":"merge!(Tree::InteractionTree) -> Tree::InteractionTree\n\nMerge interactions with same left or right environment tensor. Symmetrical merging from boundary to bulk is used here, which works well for most cases.\n\n\n\n\n\nmerge!(Tree::ObservableTree) -> Tree::ObservableTree\n\nMerge observables in Tree that share the same parent node to reduce the computation cost of environment tensors. The behavior is similar to merge! for InteractionTree, but some detailed logic is different.\n\n\n\n\n\n merge!(G::ImagTimeProxyGraph;\n      verbose::Int64=0,\n      half::Bool=false) -> nothing\n\nSearch and merge some repeated vertices in the ITP graph G.\n\nKwargs\n\n verbose::Int64 = 0\n\nDisplay the merging process if verbose > 0.\n\n half::Bool = false\n\nOnly execute the left(right) merging for the left(right) half sites if half = true.  \n\n\n\n\n\n","category":"method"},{"location":"lib/IntrTree/#FiniteMPS.addIntr!","page":"Interaction Tree","title":"FiniteMPS.addIntr!","text":"addIntr!(Tree::InteractionTree{L},\n\tOp::NTuple{N, AbstractTensorMap},\n\tsi::NTuple{N, Int64},\n\tfermionic::NTuple{N, Bool},\n\tstrength::Number;\n\tZ = nothing,\n\tpspace = nothing,\n\tname = _default_IntrName(N),\n\tIntrName = prod(string.(name)),\n) -> nothing\n\nAdd an interaction characterized by N local operators at si = (i, j, ...) sites. fermionic indicates whether each operator is fermionic or not. \n\nKwargs\n\nZ::Union{Nothing, AbstractTensorMap, Vector{<:AbstractTensorMap}}\n\nProvide the parity operator to deal with the fermionic anti-commutation relations.If Z == nothing, assume all operators are bosonic. Otherwise, a uniform (single operator) Z::AbstractTensorMap or site-dependent (length L vector) Z::Vector{<:AbstractTensorMap} should be given.\n\npspace::Union{Nothing, VectorSpace, Vector{<:VectorSpace}}\n\nProvide the local Hilbert space (VectorSpace in TensorKit.jl). This is not required in generating Hamiltonian, so the default value is set as nothing. But some processes like generating an identity MPO require this information. In such cases, a uniform or site-dependent (length L vector) pspace should be given.\n\nname::NTuple{N, Union{Symbol, String}}\n\nGive a name of each operator.\n\nIntrName::Union{Symbol, String}\n\nGive a name of the interaction, which is used as the key of Tree.Refs::Dict that stores interaction strengths. The default value is the product of each operator name.\n\n\n\n\n\naddIntr!(Tree::InteractionTree{L},\n\tOp::AbstractTensorMap,\n\tsi::Int64,\n\tstrength::Number;\n\tpspace::Union{Nothing, VectorSpace, Vector{<:VectorSpace}} = nothing,\n\tname::Union{Symbol, String} = \"A\",\n\tIntrName::Union{Symbol, String} = string.(name),\n)\n\nThe special case for on-site interactions. Compared with the standard usage, converting to tuples is not required for convenience.\n\n\n\n\n\n","category":"function"},{"location":"lib/IntrTree/#FiniteMPS.AutomataMPO","page":"Interaction Tree","title":"FiniteMPS.AutomataMPO","text":"AutomataMPO(Tree::InteractionTree;\n\tcompress::Int64 = 1,\n\ttol::Float64 = 1e-12\n) -> H::SparseMPO\n\nGenerate the Hamiltonian MPO H::SparseMPO according to an InteractionTree. \n\nKwargs\n\ncompress::Int64 = 1\n\nThe compress level. 0: without compression. 1(default): merge the same rows/columns. 2: compress via lu decomposition. 3: compress via svd. Note higher compress results in lower MPO bond dimension, however may lead to more operators in the sparse matrix at each site.\n\ntol::Float64 = 1e-12\n\nTolerance of the low-rank decompositions.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteMPS.jl","page":"Home","title":"FiniteMPS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A julia package for finite MPS/MPO-based computations of ground-state, finite-temperature and dynamical properties.","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"tutorial/Threading.md\",\n\"tutorial/Hamiltonian.md\",\n\"tutorial/Observable.md\",\n\"tutorial/Heisenberg.md\",\n\"tutorial/Hubbard.md\"\n]\nDepth = 2","category":"page"},{"location":"#LocalSpace","page":"Home","title":"LocalSpace","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"localspace/Spin.md\",\n\t\"localspace/Fermion.md\"\n]\nDepth = 2","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/TensorWrappers.md\",\n\t\"lib/MPS.md\",\n\t\"lib/Environment.md\",\n\t\"lib/ProjHam.md\",\n\t\"lib/IntrTree.md\",\n\t\"lib/ObsTree.md\",\n\t\"lib/ITP.md\",\n\t\"lib/Algebra.md\",\n     \"lib/Algorithm.md\",\n     \"lib/Deprecate.md\"]\nDepth = 1","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index/index.md\"]\nDepth = 1","category":"page"},{"location":"tutorial/Observable/#Observable","page":"Observable","title":"Observable","text":"","category":"section"},{"location":"tutorial/Observable/","page":"Observable","title":"Observable","text":"We use a similar tree structure to calculating observables. For instance, we first generate a random product state. ","category":"page"},{"location":"tutorial/Observable/","page":"Observable","title":"Observable","text":"using FiniteMPS\n\n# construct a random MPS \nL = 4\nΨ = randMPS(L, ℂ^2, ℂ^1)\n# display\nfor i in 1:L\nprintln(Ψ[i])\nend","category":"page"},{"location":"tutorial/Observable/","page":"Observable","title":"Observable","text":"Here we use randMPS to construct a random MPS whose physical spaces are all mathbbC^2 and bond spaces are all mathbbC^1 thus represents a random produce state. ","category":"page"},{"location":"tutorial/Observable/","page":"Observable","title":"Observable","text":"Next, we calculate the on-site values and spin correlations.","category":"page"},{"location":"tutorial/Observable/","page":"Observable","title":"Observable","text":"# define the S^z operator following the syntax of TensorKit.jl\nSz = TensorMap([0.5 0.0; 0.0 -0.5], ℂ^2, ℂ^2)\n\n# construct the observable tree\nTree = ObservableTree(L)\nfor i in 1:L\n     addObs!(Tree, (Sz,), (i,), (false,); name = (:Sz,))\nend\nfor i in 1:L, j in 1:L\n     addObs!(Tree, (Sz, Sz), (i, j), (false, false); name = (:Sz, :Sz))\nend\ncalObs!(Tree, Ψ)\nObs = convert(Dict, Tree)","category":"page"},{"location":"tutorial/Observable/","page":"Observable","title":"Observable","text":"Here Tree is an ObservableTree object that contains all observables to be calculated, and addObs! is the standard interface to add terms to it, analog to InteractionTree and addIntr!. Then, we call calObs! to trigger the in-place calculation in the tree, with the given MPS Ψ. Finally, we use the convert method to extract the data from the tree to a dictionary Obs. For example, ","category":"page"},{"location":"tutorial/Observable/","page":"Observable","title":"Observable","text":"Obs[\"SzSz\"][(1, 2)]","category":"page"},{"location":"tutorial/Observable/","page":"Observable","title":"Observable","text":"is the correlation \\langle S_1^z S_2^z\\rangle. One can perform a simple quantum mechanics calculation to check this result.","category":"page"},{"location":"tutorial/Observable/","page":"Observable","title":"Observable","text":"Here is just a simple example to show the basic usage, more complex examples that contain fermion correlations and multi-site correlations (e.g. pairing correlations) can be found in the concrete example for Hubbard model.","category":"page"},{"location":"tutorial/Hamiltonian/#Hamiltonian","page":"Hamiltonian","title":"Hamiltonian","text":"","category":"section"},{"location":"tutorial/Hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"Almost all algorithms in FiniteMPS.jl are based on a Hamiltonian MPO, so the starting point is always generating the Hamiltonian MPO of the given model. We provide a standard approach to this requirement.","category":"page"},{"location":"tutorial/Hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"using FiniteMPS\n\n# generate Hamiltonian of a length-L Ising chain\nL = 4\nJ = 1.0\nTree = InteractionTree(L)\nfor i in 1:L-1\n     addIntr!(Tree, (U₁Spin.Sz, U₁Spin.Sz), (i, i+1), (false, false), J; name = (:Sz, :Sz))\nend\nH = AutomataMPO(Tree)","category":"page"},{"location":"tutorial/Hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"Here, we generate the Hamiltonian of a length-4 Ising chain. We first construct an empty InteractionTree object Tree, which is used to store all interactions with a bi-tree structure. ","category":"page"},{"location":"tutorial/Hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"Then, we add the interaction terms one by one via a standard interface addIntr!, where a N-site interaction is characterized by three N-tuple of operators, sites, and fermion flags. For a Ising coupling, N=2. U₁Spin.Sz is the predefined spin operator with U(1) symmetry, more predefined operators are listed in LocalSpace section. (i, i+1) indicates the two operators are located in site i and i+1. (false, false) means both operators are bosonic.","category":"page"},{"location":"tutorial/Hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"Finally, we use AutomataMPO to construct the Hamiltonian represented by a sparse MPO, whose local tensor is an abstract matrix (gives 2 bond indices) of local rank-2 operators (give 2 physical indices).","category":"page"},{"location":"tutorial/Hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"# show the local tensors\nfor i in 1:L\n     println(H[i])\nend","category":"page"},{"location":"tutorial/Hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"One can check the result via matrix multiplication, which corresponds to contracting the bond indices. For example, multiplying the first two matrices gives I_1S_2^z I_1I_2 S_1^zS_2^z. Continue to multiply the third matrix and we obtain I_1S_2^zS_3^z + S_1^zS_2^zI_3 I_1I_2S_3^z. Finally, multiplying the last matrix indeed gives the total Ising Hamiltonian H = S_1^zS_2^z + S_2^zS_3^z + S_3^zS_4^z.","category":"page"}]
}
