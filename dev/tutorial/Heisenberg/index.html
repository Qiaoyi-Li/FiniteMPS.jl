<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Heisenberg Chain · FiniteMPS.jl</title><meta name="title" content="Heisenberg Chain · FiniteMPS.jl"/><meta property="og:title" content="Heisenberg Chain · FiniteMPS.jl"/><meta property="twitter:title" content="Heisenberg Chain · FiniteMPS.jl"/><meta name="description" content="Documentation for FiniteMPS.jl."/><meta property="og:description" content="Documentation for FiniteMPS.jl."/><meta property="twitter:description" content="Documentation for FiniteMPS.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FiniteMPS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../Threading/">Multi-threading</a></li><li><a class="tocitem" href="../Hamiltonian/">Hamiltonian</a></li><li><a class="tocitem" href="../Observable/">Observable</a></li><li class="is-active"><a class="tocitem" href>Heisenberg Chain</a><ul class="internal"><li><a class="tocitem" href="#Ground-state"><span>Ground state</span></a></li><li><a class="tocitem" href="#Finite-temperature"><span>Finite temperature</span></a></li><li><a class="tocitem" href="#Spin-dynamics"><span>Spin dynamics</span></a></li></ul></li><li><a class="tocitem" href="../Hubbard/">Hubbard Model</a></li></ul></li><li><span class="tocitem">Local Space</span><ul><li><a class="tocitem" href="../../localspace/Spin/">Spin</a></li><li><a class="tocitem" href="../../localspace/Fermion/">Fermion</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/TensorWrappers/">Tensor Wrappers</a></li><li><a class="tocitem" href="../../lib/MPS/">MPS &amp; MPO</a></li><li><a class="tocitem" href="../../lib/Environment/">Environment</a></li><li><a class="tocitem" href="../../lib/ProjHam/">Projective Hamiltonian</a></li><li><a class="tocitem" href="../../lib/IntrTree/">Interaction Tree</a></li><li><a class="tocitem" href="../../lib/ObsTree/">Observable Tree</a></li><li><a class="tocitem" href="../../lib/ITP/">Imaginary Time Proxy</a></li><li><a class="tocitem" href="../../lib/Algebra/">MPS &amp; MPO Algebra</a></li><li><a class="tocitem" href="../../lib/Algorithm/">Algorithms</a></li><li><a class="tocitem" href="../../lib/Deprecate/">Deprecate</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Heisenberg Chain</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Heisenberg Chain</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Qiaoyi-Li/FiniteMPS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Qiaoyi-Li/FiniteMPS.jl/blob/main/docs/src/tutorial/Heisenberg.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Heisenberg-Chain"><a class="docs-heading-anchor" href="#Heisenberg-Chain">Heisenberg Chain</a><a id="Heisenberg-Chain-1"></a><a class="docs-heading-anchor-permalink" href="#Heisenberg-Chain" title="Permalink"></a></h1><h2 id="Ground-state"><a class="docs-heading-anchor" href="#Ground-state">Ground state</a><a id="Ground-state-1"></a><a class="docs-heading-anchor-permalink" href="#Ground-state" title="Permalink"></a></h2><p>In this section, we compute the ground-state, finite-T and dynamical properties of a Heisenberg chain, whose Hamiltonian reads $ H = J\sum<em>{i}S</em>{i}\cdot S_{i+1}. $ Here we set <span>$J=1$</span> as energy unit and use spin SU(2) symmetry.</p><pre><code class="language-julia hljs">using FiniteMPS
using CairoMakie, Statistics, LsqFit # visualization

mkpath(&quot;figs_Heisenberg&quot;) # save figures

# parameters
L = 32
D = 128 # max bond dimension

# generate the Hamiltonian MPO
Tree = InteractionTree(L)
for i in 1:L-1
     addIntr!(Tree, SU2Spin.SS, (i, i+1), (false, false), 1.0; name = (:S, :S))
end
H = AutomataMPO(Tree)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SparseMPO{32}: total memory = 88.936 KiB
Bond  0-&gt; 1: 1 -&gt; 1
Bond  1-&gt; 2: 2 -&gt; 4
Bond  2-&gt; 3: 3 -&gt; 5
Bond  3-&gt; 4: 3 -&gt; 5
Bond  4-&gt; 5: 3 -&gt; 5
Bond  5-&gt; 6: 3 -&gt; 5
Bond  6-&gt; 7: 3 -&gt; 5
Bond  7-&gt; 8: 3 -&gt; 5
Bond  8-&gt; 9: 3 -&gt; 5
Bond  9-&gt;10: 3 -&gt; 5
Bond 10-&gt;11: 3 -&gt; 5
Bond 11-&gt;12: 3 -&gt; 5
Bond 12-&gt;13: 3 -&gt; 5
Bond 13-&gt;14: 3 -&gt; 5
Bond 14-&gt;15: 3 -&gt; 5
Bond 15-&gt;16: 3 -&gt; 5
Bond 16-&gt;17: 3 -&gt; 5
Bond 17-&gt;18: 3 -&gt; 5
Bond 18-&gt;19: 3 -&gt; 5
Bond 19-&gt;20: 3 -&gt; 5
Bond 20-&gt;21: 3 -&gt; 5
Bond 21-&gt;22: 3 -&gt; 5
Bond 22-&gt;23: 3 -&gt; 5
Bond 23-&gt;24: 3 -&gt; 5
Bond 24-&gt;25: 3 -&gt; 5
Bond 25-&gt;26: 3 -&gt; 5
Bond 26-&gt;27: 3 -&gt; 5
Bond 27-&gt;28: 3 -&gt; 5
Bond 28-&gt;29: 3 -&gt; 5
Bond 29-&gt;30: 3 -&gt; 5
Bond 30-&gt;31: 3 -&gt; 5
Bond 31-&gt;32: 2 -&gt; 4
</code></pre><p>Here <code>SU2Spin.SS</code> is a predefined 2-tuple of rank-3 operators that represents the Heisenberg interaction <span>$S_i\cdot S_j$</span>. Next, we initialize a random state in <span>$S_\textrm{tot}^z = 0$</span> sector.</p><pre><code class="language-julia hljs"># initialize a random state in S_tot = 0 sector
bspace = Rep[SU₂](0 =&gt; 1)
aspace = Rep[SU₂](i =&gt; 1 for i in 0:1/2:1)
Ψ = randMPS(fill(SU2Spin.pspace, L), vcat(bspace, fill(aspace, L-1)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MPS{32, Float64, StoreMemory}: Center = [1, 1], Norm = 1.0, total memory = 11.758 KiB
Bond  0-&gt; 1: Rep[SU₂](0=&gt;1), dim = 1 -&gt; 1
Bond  1-&gt; 2: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond  2-&gt; 3: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond  3-&gt; 4: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond  4-&gt; 5: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond  5-&gt; 6: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond  6-&gt; 7: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond  7-&gt; 8: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond  8-&gt; 9: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond  9-&gt;10: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 10-&gt;11: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 11-&gt;12: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 12-&gt;13: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 13-&gt;14: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 14-&gt;15: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 15-&gt;16: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 16-&gt;17: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 17-&gt;18: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 18-&gt;19: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 19-&gt;20: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 20-&gt;21: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 21-&gt;22: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 22-&gt;23: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 23-&gt;24: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 24-&gt;25: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 25-&gt;26: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 26-&gt;27: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 27-&gt;28: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 28-&gt;29: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 29-&gt;30: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
Bond 30-&gt;31: Rep[SU₂](0=&gt;1, 1=&gt;1), dim = 2 -&gt; 4
Bond 31-&gt;32: Rep[SU₂](1/2=&gt;1), dim = 1 -&gt; 2
</code></pre><p>Here <code>bspace = Rep[SU₂](0 =&gt; 1)</code> is the space of left boundary bond, <code>0</code> is the SU(2) quantum number of the total MPS, and <code>1</code> is the multiplicity of the trivial representation, therefore this setup indicates the total MPS is a SU(2) scalar.</p><p><code>aspace</code> is the space of bulk bonds. Note the fusing of physical space and bond space leads to a constrain due to symmetry. For example, the SU(2) quantum numbers of the bonds  exhibit a integer/half integer oscillation, as the physical space exactly shifts the quantum number by 1/2. Here we use a larger (with redundancy) initial bond space so that contraction of bond indices gives a non-vanished result. </p><pre><code class="language-julia hljs"># DMRG
NSweeps = 5
Env = Environment(Ψ&#39;, H, Ψ)
lsE = [scalar!(Env)] # initial energy
for nsweep in 1:NSweeps
     info, TO = DMRGSweep2!(Env; K = 16, trunc = truncdim(D))
	push!(lsE, info[2][1].Eg)
end
Eg = lsE[end]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-13.997315618224956</code></pre><p>Here we first construct the tri-layer environment to store the environment tensors of the local 2-site projective Hamiltonian in MPS-based DMRG. <code>scalar!</code> method triggers full contraction of the total tri-layer tensor network thus gives the initial energy.</p><p>Then we perform <code>NSweep</code> times 2-DMRG sweeping via the key function <code>DMRGSweep2!</code>, where <code>K = 16</code> is the Krylov space dimension and <code>trunc = truncdim(D)</code> is a TensorKit.jl syntax that determines the truncation scheme, i.e. keep up to <code>D</code> bond dimension. Returned <code>info</code> stores the information of a DMRG sweep and <code>TO</code> is a <code>TimerOutput</code> object contains the time usage. Here we directly extract the energy from the output information, one can also use <code>scalar!</code> again.</p><pre><code class="language-julia hljs"># plot the energy vs nsweep
fig = Figure(size = (480, 240))
ax = Axis(fig[1, 1];
     xlabel = &quot;nsweep&quot;,
     ylabel = &quot;energy per site&quot;)
scatterlines!(ax, lsE / L) # per site
save(&quot;figs_Heisenberg/GS_energy.png&quot;, fig)</code></pre><p><img src="../figs_Heisenberg/GS_energy.png" alt/></p><p>Then we compute the ground-state spin correlations.</p><pre><code class="language-julia hljs"># compute spin correlations
ObsTree = ObservableTree(L)
for i in 1:L, j in i:L
     addObs!(ObsTree, SU2Spin.SS, (i, j), (false, false); name = (:S, :S))
end
calObs!(ObsTree,  Ψ)
Obs = convert(Dict, ObsTree)

# average spin correlation with AFM correction
lsr = 1:L-1
lsSr = map(lsr) do r
	(-1.0) ^ r * mean(1:L-r) do i
          # note SU2Spin.SS corresponds to S⋅S
		Obs[&quot;SS&quot;][(i, i + r)] / 3
	end
end

# plot
fig = Figure(size = (480, 240))
ax = Axis(fig[1, 1];
     xlabel = L&quot;r&quot;,
	ylabel = L&quot;(-1)^r S(r)&quot;,
	xscale = log10,
	yscale = log10,
	limits = (1, L, nothing, nothing),
     xticks = 2.0 .^ (0:1:log(L)/log(2)),
     yticks = (10.0 .^ (-3:1:0), [L&quot;10^{-3}&quot;, L&quot;10^{-2}&quot;, L&quot;10^{-1}&quot;, L&quot;10^{0}&quot;]),
)
scatterlines!(ax, lsr, lsSr)

# fit
ids = 3:2:div(L, 2)
lsx = log.(lsr[ids])
lsy = log.(lsSr[ids])
@. model(x, p) = p[1] + p[2] * x
fit = curve_fit(model, lsx, lsy, [-log(4), -1])
lines!(ax, exp.(lsx), exp.(model(lsx, fit.param));
     color = :red,
     label = L&quot;\sim r^{%$(round(fit.param[2]; digits = 3))}&quot;
)
axislegend(ax; position = (0, 0))

save(&quot;figs_Heisenberg/GS_Sr.png&quot;, fig)</code></pre><p><img src="../figs_Heisenberg/GS_Sr.png" alt/> We reproduce the algebraic decay behaver  $ (-1)^rS(r) \sim 1/r. $</p><h2 id="Finite-temperature"><a class="docs-heading-anchor" href="#Finite-temperature">Finite temperature</a><a id="Finite-temperature-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-temperature" title="Permalink"></a></h2><p>Now we move to the finite-temperature properties via <a href="https://doi.org/10.1103/PhysRevLett.130.226502">tanTRG</a>, which belongs to an imaginary-time-evolution method based on MPO TDVP. Note we will use <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.133.026401">CBE-TDVP</a> to accelerate the computation.</p><pre><code class="language-julia hljs"># define a beta list
lsβ = vcat(2.0 .^ (-15:0), 2:16)
lslnZ = fill(NaN, length(lsβ))
lsE = fill(NaN, length(lsβ))
lsSM = fill(NaN, length(lsβ)) # AFM struct factor S(pi, pi)

# compute S(pi, pi) at ground state for comparison
calObs!(ObsTree, Ψ)
Obs = convert(Dict, ObsTree)
function calSM(Obs::Dict)
     return sum([(i, j) for i in 1:L for j in i:L]) do (i, j)
	Sij = (-1.0)^abs(i - j) * Obs[&quot;SS&quot;][(i, j)] / (3*L)
	     return i == j ? Sij : 2 * Sij
     end
end
SM_GS = calSM(Obs)

# SETTN
ρ, lsF_SETTN = SETTN(H, lsβ[1];
     CBEAlg = NaiveCBE(D + div(D, 4), 1e-8; rsvd = true),
     lsnoise = [0.01, 0.001], tol = 1e-12,
	trunc = truncdim(D) &amp; truncbelow(1e-16),
)
lslnZ[1] = 2 * log(norm(ρ))
normalize!(ρ)

# generate the trilayer environment
Env = Environment(ρ&#39;, H, ρ)
lsE[1] = scalar!(Env)
calObs!(ObsTree, ρ)
Obs = convert(Dict, ObsTree)
lsSM[1] = calSM(Obs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.2500036955434818</code></pre><p>First we define a <span>$\beta$</span> list, which determines the step length of imaginary-time cooling. <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.95.161104">SETTN</a> is adopted to initializes a high-temperature MPO, where <code>CBEAlg</code> indicates the algorithm to implement CBE. Currently only <code>NaiveCBE</code> is valid, where we directly find the optimal subspace via a svd (use random svd to accelerate), and the expanded bond dimension is set as <code>D + div(D, 4)</code>. <code>lsnoise</code> set the noise applied in the first several sweeps of variational multiplication. Next we use TDVP to cool down the system.</p><pre><code class="language-julia hljs"># TDVP cooling
for idx in 2:length(lsβ)
	dβ = lsβ[idx] - lsβ[idx-1]

	TDVPSweep1!(Env, -dβ / 2;
		CBEAlg = NaiveCBE(D + div(D, 4), 1e-8; rsvd = true),
          trunc = truncdim(D), GCsweep = true,
	)

	lslnZ[idx] = lslnZ[idx-1] + 2 * log(norm(ρ))
	normalize!(ρ)

	lsE[idx] = scalar!(Env)

	# update data stored in ObsTree
	calObs!(ObsTree, ρ)
     Obs = convert(Dict, ObsTree)
	lsSM[idx] = calSM(Obs)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: Assignment to `Obs` in soft scope is ambiguous because a global variable by the same name exists: `Obs` will be treated as a new local. Disambiguate by using `local Obs` to suppress this warning or `global Obs` to assign to the existing global variable.
└ @ Heisenberg.md:172</code></pre><p>The key function is this part is <code>TDVPSweep1!</code> that performs a single left-to-right and right-to-left 1-TDVP sweep. <code>GCsweep = true</code> indicates that a manual <code>GC.gc()</code> is called per sweep. If you suffer memory problem when using FiniteMPS.jl, the first thing to try is setting <code>CGsweep = true</code> and a stronger <code>GCstep = true</code> in the main sweeping function (e.g. <code>DMRGSweep1!</code> and <code>TDVPSweep1!</code>).</p><p>In each sweep, the normalization factor after an imaginary-time evolution is extracted to calculate the partition function <code>lnZ</code>. In order to calculate spin correlations, regenerating <code>ObsTree</code> is not needed, just use <code>calObs!</code> again to trigger the in-place update with the new MPO <code>rho</code>.</p><p>Below is a simple script for visualization, where the temperature dependence of energy <span>$e$</span>, specific heat <span>$c_V$</span> and AFM structure factor <span>$S(\pi, \pi)$</span> are shown. </p><pre><code class="language-julia hljs"># visualization

# compute C = - ∂S / ∂lnβ
lsS = lsβ .* lsE .+ lslnZ
lslnβ = log.(lsβ)
lsCe = - diff(lsS) ./ diff(lslnβ)
lsβ_c = exp.((lslnβ[1:end-1] + lslnβ[2:end])/2)

fig = Figure(size = (480, 400))
ax1, ax2, ax3 = map(1:3, [L&quot;e&quot;, L&quot;c_V&quot;, L&quot;S(\pi, \pi)&quot;]) do idx, ylabel
     ax = Axis(fig[idx, 1];
     xlabel = L&quot;T&quot;,
     ylabel = ylabel,
     xscale = log10,
     limits = (0.05, 10, nothing, nothing),
     xticks = (10.0 .^ (-2:1:1), [L&quot;10^{-2}&quot;, L&quot;10^{-1}&quot;, L&quot;10^0&quot;, L&quot;10^1&quot;]),
     xminorticks = vcat(0.02:0.01:0.09, 0.2:0.1:0.9, 2:9),
     xminorticksvisible = true)

     idx &lt; 3 &amp;&amp; hidexdecorations!(ax; grid = false, ticks = false)
     ax
end
scatterlines!(ax1, 1 ./ lsβ, lsE ./ L)
lines!(ax1, [0.05, 1], [Eg/L, Eg/L]; color = :red, label = &quot;DMRG&quot;)
axislegend(ax1; position = (0, 0.5))
scatterlines!(ax2, 1 ./ lsβ_c, lsCe ./ L)
scatterlines!(ax3, 1 ./ lsβ, lsSM)
lines!(ax3, [0.05, 1], [SM_GS, SM_GS]; color = :red)

save(&quot;figs_Heisenberg/FiniteT.png&quot;, fig)</code></pre><p><img src="../figs_Heisenberg/FiniteT.png" alt/> From this example we see that the low-temperature limit of tanTRG does shake hands with the ground state DMRG.</p><h2 id="Spin-dynamics"><a class="docs-heading-anchor" href="#Spin-dynamics">Spin dynamics</a><a id="Spin-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Spin-dynamics" title="Permalink"></a></h2><p>TODO</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Observable/">« Observable</a><a class="docs-footer-nextpage" href="../Hubbard/">Hubbard Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 30 July 2025 16:13">Wednesday 30 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
